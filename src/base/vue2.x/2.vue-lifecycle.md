---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: Vue2.x 全家桶相关知识点总结
  - name: keywords
    content: Vue2.x生命周期相关知识点介绍
---

# Vue2.x 的生命周期

::: tip 前言
vue 中不同的时机执行不同的生命周期：

- 1.首次加载依次执行 `beforeCreate` `created` `beforeMount` `mounted` `activated`
- 2.数据更新依次执行 `beforeUpdate` `updated`
- 3.数据销毁依次执行 `beforeDestory` `destoryed`
- 4.组件报错时执行 `errorCaptured`

`created`（一般用来处理请求相关的逻辑）、`mounted`（一般处理挂载之后的逻辑）、`destoryde`（一般卸载定时器或者原生 js 相关方法）
:::

::: demo

```vue
<template>
  <div style="color:red">
    <el-button @click="showLogs">显示日志</el-button>
    {{ msg }}
  </div>
</template>
<script>
let logsData = []
export default {
  data() {
    return {
      msg: "这里是组件的内容",
    }
  },
  methods: {
    showLogs() {
      this.$message(logsData.join("  |  "))
    },
  },
  mounted() {
    this.$nextTick(() => {
      logsData.push("nextTick1")
    })
    this.msg = "111"
    this.$nextTick(() => {
      logsData.push("nextTick2")
    })
  },
  beforeUpdate() {
    logsData.push("beforeUpdate")
  },
  updated() {
    logsData.push("updated")
  },
}
</script>
```

:::

- 结果

  | 组件类型 | 步骤 1       | 步骤 2  | 步骤 3    | 步骤 4    |
  | -------- | ------------ | ------- | --------- | --------- |
  | 父组件   | beforeUpdate | updated | nextTick1 | nextTick2 |

  nextTick1 、 nextTick2 为微任务，最后打印的，msg 修改引起的更新，所以 beforeUpdate、updated 生命周期同步执行？

  查看 vue 源码部分

  - 封装的组件更新函数

  ```js
  updateComponent = () => {
    vm._update(vm._render(), hydrating)
  }
  ```

  - 参数

  ```js
  const watcherOptions: WatcherOptions = {
    before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, "beforeUpdate")
      }
    },
  }
  ```

  - 将上述两个参数传入实例化渲染 watcher

  ```js
  new Watcher(
    vm,
    updateComponent,
    noop,
    watcherOptions,
    true /* isRenderWatcher */
  )
  ```

  - watcher 类，响应式数据第一次访问时进行依赖收集，会将渲染 watcher 存储起来，数据有修改时派发更新

  ```js
  export default class Watcher implements DepTarget {
    addDep(dep: Dep) {
      ...
      dep.addSub(this)
    }
    update() {
      ...
      queueWatcher(this)
    }
    run() {
      ...
      this.cb.call(this.vm, value, oldValue) // cb 就是 updateComponent
    }
  }
  ```

  - 响应式数据

  ```js
  Object.defineProperty(obj, key, {
    get: function reactiveGetter() {
      ...
      dep.depend() // 依赖收集
    },
    set: function reactiveSetter(newVal) {
      ...
      dep.notify() // 派发更新
    },
  })
  ```

  - Dep

  ```js
  export default class Dep {
    addSub(sub: DepTarget) {
      this.subs.push(sub)
    }
    depend(info?: DebuggerEventExtraInfo) {
      ...
      Dep.target.addDep(this) //Dep.target 就是 Watcher
    }
    notify(info?: DebuggerEventExtraInfo) {
      ...
    for (let i = 0, l = subs.length; i < l; i++) {
      const sub = subs[i]
        sub.update()
      }
    }
  }
  ```

  - queueWatcher

  ```js
  let waiting = false
  export function queueWatcher(watcher: Watcher) {
    ...
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue) // 异步任务 nextTick
    }
  }
  ```

  - flushSchedulerQueue

  ```js
  function resetSchedulerState() {
    waiting = flushing = false
  }
  function flushSchedulerQueue() {
    flushing = true
    let watcher, id
    queue.sort(sortCompareFn)
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index]
      watcher.before() // 生命周期函数 beforeUpdate
      watcher.run() // 更新模板
    }

    const activatedQueue = activatedChildren.slice()
    const updatedQueue = queue.slice()

    resetSchedulerState()

    callActivatedHooks(activatedQueue)
    callUpdatedHooks(updatedQueue)
    cleanupDeps()
  }
  ```

  ```js
  function callUpdatedHooks(queue: Watcher[]) {
    let i = queue.length
    while (i--) {
      const watcher = queue[i]
      callHook(vm, "updated") // 生命周期函数
    }
  }
  ```

  结论：vue 数据更新时，组件会放入队列中，由 nextTick 执行异步任务，触发 beforeUpdate、updated 回调，所以更新时 beforeUpdate、updated 异步执行

  疑问一：既然是异步执行，同样都是自带的 nextTick，为何结果不是 nextTick1 | updated | beforeUpdate | nextTick2 |

  将上述案例代码放入一个空项目 App.vue 中，再试试

  - 结果

  | 组件类型 | 步骤 1    | 步骤 2  | 步骤 3       | 步骤 4    |
  | -------- | --------- | ------- | ------------ | --------- |
  | 父组件   | nextTick1 | updated | beforeUpdate | nextTick2 |

  所以是在 vuepress 中案例代码有问题，将上述 App.vue 中的组件以子组件的形式异步加载

  - 结果

    | 组件类型 | 步骤 1       | 步骤 2  | 步骤 3    | 步骤 4    |
    | -------- | ------------ | ------- | --------- | --------- |
    | 父组件   | beforeUpdate | updated | nextTick1 | nextTick2 |

  结论：组件异步加载导致了，执行顺序的差异，但还是有问题

  ```js
  export function resolveAsyncComponent(
    factory: { (...args: any[]): any, [keye: string]: any },
    baseCtor: typeof Component
  ): typeof Component | void {
    const owner = currentRenderingInstance
    factory.owners.push(owner)
      const forceRender = (renderCompleted: boolean) => {
        for (let i = 0, l = owners.length; i < l; i++) {
          owners[i].$forceUpdate()
        }
      }
      const resolve = once((res: Object | Component) => {
        forceRender(true)
      })
      const res = factory(resolve, reject)
      // () => Promise
      if (isUndef(factory.resolved)) {
        res.then(resolve, reject)
      }
    }
  }
  ```

  - $forceUpdate

  ```js
  Vue.prototype.$forceUpdate = function () {
    const vm: Component = this
    if (vm._watcher) {
      vm._watcher.update()
    }
  }
  ```

  结论：异步组件就是将渲染 watcher 放入异步队列中

  - nextTick

  ```js
  const callbacks: Array<Function> = [] // 关键点
  let pending = false
  function flushCallbacks() {
    pending = false
    const copies = callbacks.slice(0)
    callbacks.length = 0
    for (let i = 0; i < copies.length; i++) {
      copies[i]()
    }
  }
  let timerFunc
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
  }

  export function nextTick(cb?: (...args: any[]) => any, ctx?: object) {
    let _resolve
    callbacks.push(() => {
      if (cb) {
        try {
          cb.call(ctx)
        } catch (e: any) {
          handleError(e, ctx, 'nextTick')
        }
      } else if (_resolve) {
        _resolve(ctx)
      }
    })
    if (!pending) {
      pending = true
      timerFunc()
    }
  }
  ```

  [[toc]]

在`vue`源码中，首先调用`init`方法会依次执行`beforeCreate`、`created`，然后通过`el`执行`mount`方法依次执行`beforeMount`、`mounted`

## 1.首次加载

#### 父子组件单独加载

::: demo

```vue
<template>
  <div style="color:red">
    <el-button @click="handleClick">创建/销毁子组件</el-button>
    <el-button @click="showLogs">显示日志</el-button>
    <keep-alive include="child">
      <child-part :msg="msg" v-if="show" />
    </keep-alive>
  </div>
</template>
<script>
let logsData = []
const ChildPart = {
  name: "child",
  props: {
    msg: {
      type: String,
    },
  },
  data() {
    return {}
  },
  render(h, ctx) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
  beforeCreate() {
    logsData.push("child-beforeCreate")
  },
  created() {
    logsData.push("child-created")
  },
  beforeMount() {
    logsData.push("child-beforeMount")
  },
  mounted() {
    logsData.push("child-mounted")
  },
  beforeUpdate() {
    logsData.push("child-beforeUpdate")
  },
  updated() {
    logsData.push("child-updated")
  },
  beforeDestory() {
    logsData.push("child-beforeDestory")
  },
  destoryed() {
    logsData.push("child-destoryed")
  },
  activated() {
    logsData.push("child-activated")
  },
  deactivated() {
    logsData.push("child-deactivated")
  },
  errorCaptured() {
    logsData.push("child-errorCaptured")
  },
}

export default {
  components: {
    ChildPart,
  },
  data() {
    return {
      msg: "这里是组件的内容",
      show: false,
    }
  },
  methods: {
    handleClick() {
      this.show = !this.show
    },
    showLogs() {
      this.$message(logsData.join("  |  "))
    },
  },
  beforeCreate() {
    logsData.push("parent-beforeCreate")
  },
  created() {
    logsData.push("parent-created")
  },
  beforeMount() {
    logsData.push("parent-beforeMount")
  },
  mounted() {
    logsData.push("parent-mounted")
  },
  beforeUpdate() {
    logsData.push("parent-beforeUpdate")
  },
  updated() {
    logsData.push("parent-updated")
  },
  beforeDestory() {
    logsData.push("parent-beforeDestory")
  },
  destoryed() {
    logsData.push("parent-destoryed")
  },
  activated() {
    logsData.push("parent-activated")
  },
  deactivated() {
    logsData.push("parent-deactivated")
  },
  errorCaptured() {
    logsData.push("parent-errorCaptured")
  },
}
</script>
```

:::

- 初始化

  | 组件类型 | 步骤 1              | 步骤 2         | 步骤 3             | 步骤 4         |
  | -------- | ------------------- | -------------- | ------------------ | -------------- |
  | 父组件   | parent-beforeCreate | parent-created | parent-beforeMount | parent-mounted |

- 创建子组件

  | 组件类型 | 步骤 1              | 步骤 2             | 步骤 3        | 步骤 4            | 步骤 5        | 步骤 6          | 步骤 7         |
  | -------- | ------------------- | ------------------ | ------------- | ----------------- | ------------- | --------------- | -------------- |
  | 父组件   | parent-beforeUpdate |                    |               |                   |               |                 | parent-updated |
  | 子组件   |                     | child-beforeCreate | child-created | child-beforeMount | child-mounted | child-activated |                |

#### 父子组件一起加载

::: demo

```vue
<template>
  <div style="color:red">
    <el-button @click="showLogs">显示日志</el-button>
    <keep-alive include="child">
      <child-part :msg="msg" />
    </keep-alive>
  </div>
</template>
<script>
let logsData = []
const ChildPart = {
  name: "child",
  props: {
    msg: {
      type: String,
    },
  },
  data() {
    return {}
  },
  render(h, ctx) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
  beforeCreate() {
    logsData.push("child-beforeCreate")
  },
  created() {
    logsData.push("child-created")
  },
  beforeMount() {
    logsData.push("child-beforeMount")
  },
  mounted() {
    logsData.push("child-mounted")
  },
  beforeUpdate() {
    logsData.push("child-beforeUpdate")
  },
  updated() {
    logsData.push("child-updated")
  },
  beforeDestory() {
    logsData.push("child-beforeDestory")
  },
  destoryed() {
    logsData.push("child-destoryed")
  },
  activated() {
    logsData.push("child-activated")
  },
  deactivated() {
    logsData.push("child-deactivated")
  },
  errorCaptured() {
    logsData.push("child-errorCaptured")
  },
}

export default {
  components: {
    ChildPart,
  },
  data() {
    return {
      msg: "这里是组件的内容",
    }
  },
  methods: {
    showLogs() {
      this.$message(logsData.join("  |  "))
    },
  },
  beforeCreate() {
    logsData.push("parent-beforeCreate")
  },
  created() {
    logsData.push("parent-created")
  },
  beforeMount() {
    logsData.push("parent-beforeMount")
  },
  mounted() {
    logsData.push("parent-mounted")
  },
  beforeUpdate() {
    logsData.push("parent-beforeUpdate")
  },
  updated() {
    logsData.push("parent-updated")
  },
  beforeDestory() {
    logsData.push("parent-beforeDestory")
  },
  destoryed() {
    logsData.push("parent-destoryed")
  },
  activated() {
    logsData.push("parent-activated")
  },
  deactivated() {
    logsData.push("parent-deactivated")
  },
  errorCaptured() {
    logsData.push("parent-errorCaptured")
  },
}
</script>
```

:::

- 初始化

  | 组件类型 | 步骤 1              | 步骤 2         | 步骤 3             | 步骤 4             | 步骤 5        | 步骤 6            | 步骤 7        | 步骤 8          | 步骤 9         |
  | -------- | ------------------- | -------------- | ------------------ | ------------------ | ------------- | ----------------- | ------------- | --------------- | -------------- |
  | 父组件   | parent-beforeCreate | parent-created | parent-beforeMount |                    |               |                   |               |                 | parent-mounted |
  | 子组件   |                     |                |                    | child-beforeCreate | child-created | child-beforeMount | child-mounted | child-activated |                |

### 1.1 beforeCreate

| 类型       | 说明                 |
| ---------- | -------------------- |
| 同步执行？ | 是                   |
| 访问 dom？ | 否                   |
| 访问属性   | 否                   |
| 访问方法   | 否                   |
| 作用       | 一些插件混入一些方法 |

- 初始化自己的生命周期 并且 绑定自己的事件
- 在实例初始化之后，数据观测和暴露了一些有用的实例属性与方法。

- 实例化
  - `new Vue()`
  ```js
  var data = { a: 1 }
  var vm = new Vue({
    el: "#example",
    data: data,
  })
  ```
- 数据观测
  - 在 vue 的响应式系统中加入 data 对象所有的数据
  ```js
  vm.$data === data // => true
  ```
- 暴露属性和方法
  - 一些 vue 自带的属性和方法
  ```js
  vm.$el === document.getElementById("example") // => true
  // $watch 是一个实列方法
  vm.$watch("a", function(new, old) {
    // 这个回调将在 `vm.a`改变后调用
  })
  ```

### 1.2 created

- 可以获取数据和调用方法
- el 属性对生命周期的影响
  - 有 el 属性
  ```js
  new Vue({
    el: "#app",
    beforeCreate: function () {
      console.log("调用了beforeCreate")
    },
    created: function () {
      console.log("调用了created")
    },
    beforeMount: function () {
      console.log("调用了beforeMount")
    },
    mounted: function () {
      console.log("调用了mounted")
    },
  })
  // 输出结果
  // 调用了beforeCreate
  // 调用了created
  // 调用了beforeMount
  // 调用了mounted
  ```
  - 没有 el 属性，没有 vm.\$mount
  ```js
  // 在没有el属性的情况下，没有vm.$mount
  new Vue({
    beforeCreate: function () {
      console.log("调用了beforeCreate")
    },
    created: function () {
      console.log("调用了created")
    },
    beforeMount: function () {
      console.log("调用了beforeMount")
    },
    mounted: function () {
      console.log("调用了mounted")
    },
  })
  // 输出结果
  // 调用了beforeCreate
  // 调用了created
  ```
  - 没有 el 属性，有 vm.\$mount
  ```js
  // 在没有el属性的情况下，但是有vm.$mount方法
  var vm = new Vue({
    beforeCreate: function () {
      console.log("调用了beforeCreate")
    },
    created: function () {
      console.log("调用了created")
    },
    beforeMount: function () {
      console.log("调用了beforeMount")
    },
    mounted: function () {
      console.log("调用了mounted")
    },
  })
  vm.$mount("#app")
  // 输出结果
  // 调用了beforeCreate
  // 调用了created
  // 调用了beforeMount
  // 调用了mounted
  ```
- template 属性对生命周期的影响
  - 在实例内部有 template 属性的时候，直接用内部的节点，然后调用 render 函数去渲染
  ```js
  new Vue({
    el: "#app",
    template: '<div id="app">hello world</div>',
  })
  //页面上渲染出了hello world
  ```
  - 在实例内部没有找到 template,就调用外部的 html
  ```js
  ;<div id="app">hello world</div>
  new Vue({
    el: "#app",
  })
  // 页面上渲染出了hello world
  ```
  - 实例内部的 template 属性比外部的优先级高
  ```js
  ;<div id="app">hello world2</div>
  new Vue({
    el: "#app",
    template: '<div id="app">hello world1</div>',
  })
  // 页面上渲染出了hello world1
  ```
  - 要是前面两者都不满足，那么就抛出错误
- 关于这个生命周期中的一些问题
  - 为什么 el 属性的判断在 template 之前？因为 el 是一个选择器，比如上述例子中我们用到的最多的是 id 选择器 app，vue 实例需要用这个 el 去 template 中寻找对应的选择器
  - 实际上，vue 实例中还有一种 render 选项，我们可以从文档上看它的用法
  ```js
  new Vue({
    el: '#app',
    render() {
      return (...)
    }
  })
  ```
  - 上述三者的渲染优先级：render 函数>template>外部 html
  - vue 编译过程--把 template 编译成 render 函数的过程

### 1.3 beforeMount

- 第一次调用渲染函数之前

```js
;<div id="app">
  <p>{{ message }}</p>
</div>

new Vue({
  el: "#app",
  data: {
    message: 1,
  },
  beforeMount: function () {
    console.log("调用了beforeMount")
    console.log(this.message)
    console.log(this.$el)
  },
  mounted: function () {
    console.log("调用了mounted")
    console.log(this.message)
    console.log(this.$el)
  },
})

// 输出的结果：
// 调用了beforeMount
// 1
// <div>
// </div>

// 调用了mounted
// 1
// <div id="app">
//  <p>1</p>
// </div>
```

创建 vue 实例的\$el，然后用它替代 el 属性

### 1.4 mounted

- 获取真实 dom 因为页面已经渲染完了

```js
;<div id="app">
  <p>{{ message }}</p>
</div>

new Vue({
  el: "#app",
  data: {
    message: 1,
  },
  beforeMount: function () {
    console.log("调用了beforeMount")
    console.log(this.message)
    console.log(this.$el)
  },
  mounted: function () {
    console.log("调用了mounted")
    console.log(this.message)
    console.log(this.$el)
  },
})

// 输出的结果：
// 调用了beforeMount
// 1
// <div>
// </div>

// 调用了mounted
// 1
// <div id="app">
//  <p>1</p>
// </div>
```

创建 vue 实例的\$el，然后用它替代 el 属性

## 2.数据更新

#### 父子组件单独加载

::: demo

```vue
<template>
  <div style="color:red">
    <el-button @click="updateMsg">更新父组件传入子组件数据</el-button>
    <el-button @click="handleClick">创建/销毁子组件</el-button>
    <el-button @click="showLogs">显示日志</el-button>
    <el-button @click="clearLogs">清空日志</el-button>
    <keep-alive include="child">
      <child-part :msg="msg" v-if="show" />
    </keep-alive>
  </div>
</template>
<script>
let logsData = []
const ChildPart = {
  name: "child",
  props: {
    msg: {
      type: String,
    },
  },
  data() {
    return {}
  },
  render(h, ctx) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
  beforeCreate() {
    this.$nextTick(() => {
      logsData.push("child-nextTick")
    })
    logsData.push("child-beforeCreate")
  },
  created() {
    logsData.push("child-created")
  },
  beforeMount() {
    logsData.push("child-beforeMount")
  },
  mounted() {
    logsData.push("child-mounted")
  },
  beforeUpdate() {
    logsData.push("child-beforeUpdate")
  },
  updated() {
    logsData.push("child-updated")
  },
  beforeDestory() {
    logsData.push("child-beforeDestory")
  },
  destoryed() {
    logsData.push("child-destoryed")
  },
  activated() {
    logsData.push("child-activated")
  },
  deactivated() {
    logsData.push("child-deactivated")
  },
  errorCaptured() {
    logsData.push("child-errorCaptured")
  },
}

export default {
  components: {
    ChildPart,
  },
  data() {
    return {
      msg: "这里是组件的内容",
      show: false,
    }
  },
  methods: {
    updateMsg() {
      this.msg = this.msg + 1
    },
    handleClick() {
      this.show = !this.show
    },
    showLogs() {
      this.$message(logsData.join("  |  "))
    },
    clearLogs() {
      logsData = []
    },
  },
  beforeCreate() {
    this.$nextTick(() => {
      logsData.push("parent-nextTick")
    })
    logsData.push("parent-beforeCreate")
  },
  created() {
    logsData.push("parent-created")
  },
  beforeMount() {
    logsData.push("parent-beforeMount")
  },
  mounted() {
    logsData.push("parent-mounted")
  },
  beforeUpdate() {
    logsData.push("parent-beforeUpdate")
  },
  updated() {
    logsData.push("parent-updated")
  },
  beforeDestory() {
    logsData.push("parent-beforeDestory")
  },
  destoryed() {
    logsData.push("parent-destoryed")
  },
  activated() {
    logsData.push("parent-activated")
  },
  deactivated() {
    logsData.push("parent-deactivated")
  },
  errorCaptured() {
    logsData.push("parent-errorCaptured")
  },
}
</script>
```

:::

- 初始化

  | 组件类型 | 步骤 1              | 步骤 2         | 步骤 3             | 步骤 4         | 步骤 5          |
  | -------- | ------------------- | -------------- | ------------------ | -------------- | --------------- |
  | 父组件   | parent-beforeCreate | parent-created | parent-beforeMount | parent-mounted | parent-nextTick |

- 创建子组件

  | 组件类型 | 步骤 1              | 步骤 2             | 步骤 3        | 步骤 4            | 步骤 5        | 步骤 6          | 步骤 7         | 步骤 8         |
  | -------- | ------------------- | ------------------ | ------------- | ----------------- | ------------- | --------------- | -------------- | -------------- |
  | 父组件   | parent-beforeUpdate |                    |               |                   |               |                 | parent-updated |
  | 子组件   |                     | child-beforeCreate | child-created | child-beforeMount | child-mounted | child-activated |                | child-nextTick |

#### 父子组件一起加载

::: demo

```vue
<template>
  <div style="color:red">
    <el-button @click="updateMsg">更新父组件传入子组件数据</el-button>
    <el-button @click="showLogs">显示日志</el-button>
    <el-button @click="clearLogs">清空日志</el-button>
    <keep-alive include="child">
      <child-part :msg="msg" />
    </keep-alive>
  </div>
</template>
<script>
let logsData = []
const ChildPart = {
  name: "child",
  props: {
    msg: {
      type: String,
    },
  },
  data() {
    return {}
  },
  render(h, ctx) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
  beforeCreate() {
    logsData.push("child-beforeCreate")
  },
  created() {
    logsData.push("child-created")
  },
  beforeMount() {
    logsData.push("child-beforeMount")
  },
  mounted() {
    logsData.push("child-mounted")
  },
  beforeUpdate() {
    logsData.push("child-beforeUpdate")
  },
  updated() {
    logsData.push("child-updated")
  },
  beforeDestory() {
    logsData.push("child-beforeDestory")
  },
  destoryed() {
    logsData.push("child-destoryed")
  },
  activated() {
    logsData.push("child-activated")
  },
  deactivated() {
    logsData.push("child-deactivated")
  },
  errorCaptured() {
    logsData.push("child-errorCaptured")
  },
}

export default {
  components: {
    ChildPart,
  },
  data() {
    return {
      msg: "这里是组件的内容",
    }
  },
  methods: {
    updateMsg() {
      this.msg = this.msg + 1
    },
    showLogs() {
      this.$message(logsData.join("  |  "))
    },
    clearLogs() {
      logsData = []
    },
  },
  beforeCreate() {
    logsData.push("parent-beforeCreate")
  },
  created() {
    logsData.push("parent-created")
  },
  beforeMount() {
    logsData.push("parent-beforeMount")
  },
  mounted() {
    logsData.push("parent-mounted")
  },
  beforeUpdate() {
    logsData.push("parent-beforeUpdate")
  },
  updated() {
    logsData.push("parent-updated")
  },
  beforeDestory() {
    logsData.push("parent-beforeDestory")
  },
  destoryed() {
    logsData.push("parent-destoryed")
  },
  activated() {
    logsData.push("parent-activated")
  },
  deactivated() {
    logsData.push("parent-deactivated")
  },
  errorCaptured() {
    logsData.push("parent-errorCaptured")
  },
}
</script>
```

:::

### 2.1 beforeUpdate

- 这个过程中，我们会发现，当一个数据发生改变是，你的视图也将随之改变，整个更新的过程是：

数据改变-->虚拟 dom 改变-->调用这两个生命钩子去改变视图

- 这个数据只有模板中的数据绑定了才会发生更新

```js
var vm = new Vue({
  el: "#app",
  template: '<div id="app">{{a}}</div>',
  beforeUpdate: function () {
    console.log("调用了beforeUpdate")
  },
  updated: function () {
    console.log("调用了uodated")
  },
  data: {
    a: 1,
  },
})

vm.a = 2

// 输出结果：
// 调用了beforeUpdate
// 调用了uodated
```

- 没有绑定

```js
var vm = new Vue({
  el: "#app",
  template: '<div id="app"></div>',
  beforeUpdate: function () {
    console.log("调用了beforeUpdate")
  },
  updated: function () {
    console.log("调用了uodated")
  },
  data: {
    a: 1,
  },
})

vm.a = 2
//这种情况在控制台中是什么都不会输出的。
```

### 2.2 updated

Vue 的 updated 钩子是异步的。Vue 在 DOM 更新完成后，会通过异步队列来执行 updated 钩子函数，但不保证它会在 DOM 更新完成后的下一个事件循环中同步触发。这意味着，如果你在 updated 钩子中需要访问更新后的 DOM 元素，你应该使用 this.$nextTick 来确保你的代码在 DOM 更新完成后执行

- 一般不要操作数据 可能会导致死循环
- 这个过程中，我们会发现，当一个数据发生改变是，你的视图也将随之改变，整个更新的过程是：

数据改变-->虚拟 dom 改变-->调用这两个生命钩子去改变视图

- 这个数据只有模板中的数据绑定了才会发生更新

```js
var vm = new Vue({
  el: "#app",
  template: '<div id="app">{{a}}</div>',
  beforeUpdate: function () {
    console.log("调用了beforeUpdate")
  },
  updated: function () {
    console.log("调用了uodated")
  },
  data: {
    a: 1,
  },
})

vm.a = 2

// 输出结果：
// 调用了beforeUpdate
// 调用了uodated
```

- 没有绑定

```js
var vm = new Vue({
  el: "#app",
  template: '<div id="app"></div>',
  beforeUpdate: function () {
    console.log("调用了beforeUpdate")
  },
  updated: function () {
    console.log("调用了uodated")
  },
  data: {
    a: 1,
  },
})

vm.a = 2
//这种情况在控制台中是什么都不会输出的。
```

## 3.数据销毁

#### 父组件内销毁子组件（keep-alive）

::: demo

```vue
<template>
  <div style="color:red">
    <el-button @click="handleClick">销毁/创建子组件</el-button>
    <el-button @click="showLogs">显示日志</el-button>
    <el-button @click="clearLogs">清空日志</el-button>
    <keep-alive include="child">
      <child-part :msg="msg" v-if="show" />
    </keep-alive>
  </div>
</template>
<script>
let logsData = []
const ChildPart = {
  name: "child",
  props: {
    msg: {
      type: String,
    },
  },
  data() {
    return {}
  },
  render(h, ctx) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
  beforeCreate() {
    logsData.push("child-beforeCreate")
  },
  created() {
    logsData.push("child-created")
  },
  beforeMount() {
    logsData.push("child-beforeMount")
  },
  mounted() {
    logsData.push("child-mounted")
  },
  beforeUpdate() {
    logsData.push("child-beforeUpdate")
  },
  updated() {
    logsData.push("child-updated")
  },
  beforeDestory() {
    logsData.push("child-beforeDestory")
  },
  destoryed() {
    logsData.push("child-destoryed")
  },
  activated() {
    logsData.push("child-activated")
  },
  deactivated() {
    logsData.push("child-deactivated")
  },
  errorCaptured() {
    logsData.push("child-errorCaptured")
  },
}

export default {
  components: {
    ChildPart,
  },
  data() {
    return {
      msg: "这里是组件的内容",
      show: true,
    }
  },
  methods: {
    handleClick() {
      this.show = !this.show
    },
    showLogs() {
      this.$message(logsData.join("  |  "))
    },
    clearLogs() {
      logsData = []
    },
  },
  beforeCreate() {
    logsData.push("parent-beforeCreate")
  },
  created() {
    logsData.push("parent-created")
  },
  beforeMount() {
    logsData.push("parent-beforeMount")
  },
  mounted() {
    logsData.push("parent-mounted")
  },
  beforeUpdate() {
    logsData.push("parent-beforeUpdate")
  },
  updated() {
    logsData.push("parent-updated")
  },
  beforeDestory() {
    logsData.push("parent-beforeDestory")
  },
  destoryed() {
    logsData.push("parent-destoryed")
  },
  activated() {
    logsData.push("parent-activated")
  },
  deactivated() {
    logsData.push("parent-deactivated")
  },
  errorCaptured() {
    logsData.push("parent-errorCaptured")
  },
}
</script>
```

:::

#### 父组件内销毁子组件

::: demo

```vue
<template>
  <div style="color:red">
    <el-button @click="handleClick">销毁/创建子组件</el-button>
    <el-button @click="showLogs">显示日志</el-button>
    <el-button @click="clearLogs">清空日志</el-button>
    <child-part1 :msg="msg" v-if="show" />
  </div>
</template>
<script>
let logsData = []
const ChildPart1 = {
  name: "child",
  props: {
    msg: {
      type: String,
    },
  },
  data() {
    return {}
  },
  render(h, ctx) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
  beforeCreate() {
    logsData.push("child-beforeCreate")
  },
  created() {
    logsData.push("child-created")
  },
  beforeMount() {
    logsData.push("child-beforeMount")
  },
  mounted() {
    logsData.push("child-mounted")
  },
  beforeUpdate() {
    logsData.push("child-beforeUpdate")
  },
  updated() {
    logsData.push("child-updated")
  },
  beforeDestory() {
    logsData.push("child-beforeDestory")
  },
  destoryed() {
    logsData.push("child-destoryed")
  },
  activated() {
    logsData.push("child-activated")
  },
  deactivated() {
    logsData.push("child-deactivated")
  },
  errorCaptured() {
    logsData.push("child-errorCaptured")
  },
}

export default {
  components: {
    ChildPart1,
  },
  data() {
    return {
      msg: "这里是组件的内容",
      show: true,
    }
  },
  methods: {
    handleClick() {
      this.show = !this.show
    },
    showLogs() {
      this.$message(logsData.join("  |  "))
    },
    clearLogs() {
      logsData = []
    },
  },
  beforeCreate() {
    logsData.push("parent-beforeCreate")
  },
  created() {
    logsData.push("parent-created")
  },
  beforeMount() {
    logsData.push("parent-beforeMount")
  },
  mounted() {
    logsData.push("parent-mounted")
  },
  beforeUpdate() {
    logsData.push("parent-beforeUpdate")
  },
  updated() {
    logsData.push("parent-updated")
  },
  beforeDestory() {
    logsData.push("parent-beforeDestory")
  },
  destoryed() {
    logsData.push("parent-destoryed")
  },
  activated() {
    logsData.push("parent-activated")
  },
  deactivated() {
    logsData.push("parent-deactivated")
  },
  errorCaptured() {
    logsData.push("parent-errorCaptured")
  },
}
</script>
```

:::

### 3.1 beforeDestory

- 当前实列可以用

在 beforeDestory 生命钩子调用之前，所有实例都可以用，但是当调用后，vue 实例指示的所有东西都会解绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁。

### 3.2 destoryed

- 实列上的方法 监听都被移除掉
  在 beforeDestory 生命钩子调用之前，所有实例都可以用，但是当调用后，vue 实例指示的所有东西都会解绑定，所有的事件监听器都会被移除，所有的子实例也会被销毁。
- this.$destory()

## 4.其他生命钩子

### 4.1 activated

`keep-alive`子组件激活的时候调用，具体时机为首次加载页面和页面更新都会调用

### 4.2 deactivated

`keep-alive`子组件停用的时候调用

### 4.3 errorCaptured

当捕获一个来自子孙组件的错误时被调用

::: tip 总结

通过上述案例可以了解到:

- 1.vue 中父子组件生命周期嵌套顺序加载
- 2.有些生命周期为同步加载，有些为异步加载

:::

<!-- <Vssue /> -->
