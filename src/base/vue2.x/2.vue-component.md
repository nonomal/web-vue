---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: Vue2.x 全家桶相关知识点总结
  - name: keywords
    content: Vue2.x组件通信方式总结
---

# Vue2.x（components）

::: tip 前言

- 在 Vue 项目中，组件加载流程为：template --> render --> Vnode --> element
- 据此分别在其不同阶段介绍不同方式挂载组件到页面中

:::

## 1.template

- template 中的代码会转化为 render 函数
- 如果是在 vue/cli 工程中，一般会通过 vue-loader 转化为 render 函数
- 如果是在运行时项目中，是通过 complie 函数编译转换成 render 函数

### 1.1 同步组件

#### 1.1.1 sfc

最常见的组件

::: demo

```vue
<template>
  <div class="container" style="color:red">
    <container />
  </div>
</template>
<script>
export default {
  components: {
    container: {
      props: {},
      data() {
        return {
          msg: "这里是组件的内容",
        }
      },
      render(h) {
        return (
          <div>
            <p>{this.msg}</p>
          </div>
        )
      },
    },
  },
  data() {
    return {}
  },
}
</script>
```

:::

#### 1.1.2 运行时

- 内部靠编译函数编译，vue 打包代码会比 cli 的大一些
- 一些特殊项目中使用 vue（如：abi、老项目、动态编辑组件）

```html
<body>
  <div id="app"></div>
</body>
<script>
  new Vue({
    el: "#app",
    components: {
      container: {
        props: {},
        data() {
          return {
            msg: "这里是组件的内容",
          }
        },
        template: `
         <div>
              <p>{this.msg}</p>
            </div>
        `,
      },
    },
    template: `
          <div class="container" style="color:red">
            <container />
          </div>
    `,
    data() {
      return {}
    },
  })
</script>
```

### 1.2 异步组件

- 通常页面很多子组件需要在一定条件下展示，页面性能有要求，可以使用异步组件对页面进行`按需加载`

::: demo

```vue
<template>
  <div class="container" style="color:red">
    <container />
  </div>
</template>
<script>
export default {
  components: {
    // container: import(xxx)),
    container: () => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve({
            props: {},
            data() {
              return {
                msg: "这里是组件的内容",
              }
            },
            render(h) {
              return (
                <div>
                  <p>{this.msg}</p>
                </div>
              )
            },
          })
        }, 1000)
      })
    },
  },
  data() {
    return {}
  },
}
</script>
```

:::

### 1.3 functional

- 内部没有逻辑交互（无 methods 方法、也没有 mounted 等任何生命周期处理函数），没有状态修改(无 data)
- 所有动态数据都从父组件传递进来（只有 props），数据变为常数，组件只用于展示数据，模板编译时 ast 会做静态标记，`组件不会被更新`直接跳过

::: demo

```vue
<template functional>
  <ul style="color:red">
    <li v-for="(item, index) in items" :key="index" @click="itemClick(item)">
      {{ item }}
    </li>
  </ul>
</template>
<script>
export default {
  props: {
    items: {
      type: Array,
      default: () => ["这是函数式组件", "这是函数式组件", "这是函数式组件"],
    },
    itemClick: {
      type: Function,
      default: () => {},
    },
  },
}
</script>
```

:::

### 1.4 abstract

- 抽象组件和普通的组件类似，只是他们添加额外的行为，不向 DOM 呈现任何内容
- vue 中`component`、`slot`、`keep-alive`、`transition`、`transition-group`都是通过抽象组件实现的

### 1.5 递归组件

- 利用组件名称，在页面特定条件下反复加载

#### 1.4.1 防抖案例

```vue
<script>
import { get, debounce, set } from "loadsh"
export default {
  name: "debounce",
  abstract: true, //标记为抽象组件
  render() {
    let vnode = this.$slots.default[0] // 子组件的vnode
    if (vnode) {
      let event = get(vnode, `data.on.click`) // 子组件绑定的click事件
      if (typeof event === "function") {
        set(vnode, `data.on.click`, debounce(event, 1000))
      }
    }
    return vnode
  },
}
</script>
```

#### 1.4.2 component

- 动态切换不同类型的组件，动态表单中用的比较多

::: demo

```vue
<template>
  <div>
    <el-form>
      <el-form-item>
        <component
          v-if="data.name"
          :is="data.name"
          v-bind="data.props"
        ></component>
      </el-form-item>
    </el-form>
    <web-button @click="handleChange('el-input')">el-input</web-button>
    <web-button @click="handleChange('el-radio')">el-radio</web-button>
    <web-button @click="handleChange('el-select')">el-select</web-button>
  </div>
</template>
<script>
export default {
  data() {
    return {
      data: {
        name: "",
        props: {},
      },
      target: Object.freeze({
        "el-input": {
          name: "el-input",
          props: { value: "10" },
        },
        "el-radio": {
          name: "el-radio",
          props: { value: "1", label: "1" },
        },
        "el-select": {
          name: "el-select",
          props: { value: "相机" },
        },
      }),
    }
  },
  methods: {
    handleChange(name) {
      this.data = this.target[name]
    },
  },
}
</script>
```

:::

## 2.render

### 2.1 render 函数

- template 写标签有时候不灵活，用 render 可以灵活处理标签

::: demo

```vue
<template>
  <div class="container">
    <container />
  </div>
</template>
<script>
export default {
  components: {
    container: {
      data() {
        return {
          show: false,
        }
      },
      render(h) {
        let childNode
        if (this.show) {
          childNode = h("p", "组件隐藏内容")
        } else {
          childNode = h("p", "组件内容")
        }
        return h(
          "div",
          {
            attrs: {
              class: "text",
            },
            style: {
              color: "red",
            },
          },
          [childNode]
        )
      },
    },
  },
  data() {
    return {}
  },
}
</script>
```

:::

## 3.Vnode

### 3.1 $createElement

- $createElement 就是 render 函数，只是这里比较灵活

::: demo

```vue
<template>
  <div>
    <el-button @click="handleClick">点击弹框</el-button>
  </div>
</template>
<script>
let container = {
  props: {},
  data() {
    return {
      msg: "这里是组件的内容",
    }
  },
  render(h) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
}
export default {
  methods: {
    handleClick() {
      const h = this.$createElement
      let vNode = h(container, {
        props: {},
        methods: {},
      })
      this.$confirm("提示", {
        title: "提示",
        message: vNode,
        showCancelButton: true,
        confirmButtonText: "确定",
        concelButtonText: "取消",
        type: "warning",
      })
    },
  },
}
</script>
```

:::

## 4.element

- 将 vue 直接挂载到指定节点上
- 根结点在 `new Vue({el:xxx})`也可以直接挂载

### 4.1 extend

- 一些项目中有些页面不是 vue 开发的（d3.js、echarts）等，某个地方需要写一些普通的页面，就可以中这种方式插入到指定 dom 元素下

::: demo

```vue
<template>
  <div style="color:red">
    <div id="vueDemo"></div>
  </div>
</template>
<script>
export default {
  mounted() {
    let Profile = this.$vue.extend({
      props: {
        message: {
          type: String,
        },
      },
      data() {
        return {
          msg: "这里是组件的内容",
        }
      },
      render(h) {
        return (
          <div>
            <p>data数据：{this.msg}</p>
            <p>props数据：{this.message}</p>
          </div>
        )
      },
    })

    const compsData = { propsData: { message: "我是自组件传入的数据" } }
    const instance = new Profile(compsData)
    instance.$mount("#vueDemo")
    // instance.$mount().innerHTML; // 生成dom元素
  },
}
</script>
```

:::

### 4.2 patch

- 将目标组件插入到指定 dom 下

::: demo

```vue
<template>
  <div style="color:red">
    <div ref="parent"></div>
  </div>
</template>
<script>
let container = {
  props: {},
  data() {
    return {
      msg: "这里是组件的内容",
    }
  },
  render(h) {
    return (
      <div>
        <p>{this.msg}</p>
      </div>
    )
  },
}
export default {
  mounted() {
    const h = this.$createElement
    const vNode = h(container, {
      props: {},
      methods: {},
    })
    this.__patch__(this.$refs.parent, vNode)
  },
}
</script>
```

:::
