---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十.编码技巧

::: tip 前言
总结一些开发中常见的问题，优化改善编码技巧，提高代码质量
:::

## 1.条件判断

- 常见条件判断`if`

  ```js
  let name = "lisi"
  let age = 18
  if (name === "zhangsan") {
    age = 21
  } else if (name === "lisi") {
    age = 18
  } else if (name === "wangwu") {
    age = 12
  }
  ```

- 常见条件判断`switch`

  ```js
  switch (name) {
    case "zhangsan":
      age = 21
      break
    case "lisi":
      age = 18
      break
    case "wangwu":
      age = 12
      break
  }
  ```

  ::: tip 推荐

  - 使用对象的形式简写

    ```js
    let name = "lisi"
    let obj = { zhangsan: 21, lisi: 18, wangwu: 12 }
    let age = obj[name] || 18
    ```

  :::

  ::: warning 注意
  以上这种技巧适用于循环判断一次赋值的情况，如果判断过后有较多处理逻辑的还需要使用 if 或 switch 等方法。
  :::

## 2.生成数组

- 常见生成数组方式

  ```js
  let hours = []
  for (let i = 0; i < 24; i++) {
    hours.push(i + "时")
  }
  ```

  ::: tip 推荐

  - 使用 Array.from 生成数组

    ```js
    let hours = Array.from({ length: 24 }, (value, index) => index + "时")
    ```

  :::

## 3.按需加载

- 常见加载页面方式

  ```js
  import home from'@/page/index/index'
  ...
  {
    path: '/index',
    component: home,
    name: '首页'
  }
  ...
  ```

  ::: tip 推荐

  - 按需加载页面

    ```js {4}
    ...
    {
      path: '/index',
      component: () => import('@/page/index/index'),
      name: '首页'
    }
    ...
    ```

  :::

## 4.按需渲染

在 Vue 页面中，一些模块可能需要用户主动触发才会显示，比如弹框组件等这样的子组件，那么我们可以使用 `v-if` 来进行按需渲染，没必要一进页面就渲染所有模块

## 5.路由跳转

- 常见的方式`href`

  ```js
  location.href = "/home"
  ```

- 常见的方式`hash`

  ```js
  location.hash = "/home"
  ```

- 使用`path`：优于以上方式，当路径不变，路由方式修改不会影响跳转结果

  ```js
  this.$router.push({
    path: "home",
  })
  ```

  ::: tip 推荐

  - 使用`name`: 对于 path，name 使用起来就方便多了，因为其具有唯一性，即使我们修改了 path，还可以使用原来的 `name` 值进行跳转

    ```js
    this.$router.push({
      name: "home",
    })
    ```

  :::

## 6.v-for 问题

使用 index 作为 key 可能导致更新问题，尽量使用不变的 id

## 7.computed

尽量使用 computed 代替 watch，computed 可以理解为懒加载版的 watch,使用 computed 可以提高性能

## 8.枚举字段

- 常见项目一些变量像全局变量一样散落在项目的各个地方，难以管理

  ```js
  localStorage.token = "xxx" // a.page
  localStorage.token = "xxx" // b.page
  localStorage.token = "xxx" // c.page
  ```

  ::: tip 推荐

  - 定义枚举字段

    ```js
    // types.js
    export const USER_NAME = "userName"
    export const TOKEN = "token" // 当需要修改变量名（token）时，直接修改文件中的值即可，无需修改使用它的页面，同时这也可以避免命名冲突等问题的出现
    ```

  - 引用枚举字段

    ```js
    import { USER_NAME, TOKEN } from "../types.js"
    sessionStorage[USER_NAME] = "张三"
    localStorage[TOKEN] = "xxx"
    ```

  :::

## 9.setInterval 问题

一般情况下我们在项目里不建议使用 `setInterval`，因为其会存在代码的执行间隔比预期小以及 “丢帧” 的现象，原因在于其本身的实现逻辑。很多人会认为 setInterval 中第二个时间参数的作用是经过该毫秒数执行回调方法，其实不然，其真正的作用是**经过该毫秒数将回调方法放置到队列中去**，但是如果队列中存在正在执行的方法，其会等待之前的方法完毕再执行，如果存在还未执行的代码实例，其不会插入到队列中去，也就产生了 “丢帧”。

而 setTimeout 并不会出现这样的现象，因为每一次调用都会产生了一个新定时器，同时在前一个定时器代码执行完之前，不会向队列插入新的定时器代码。

  ```js
  setInterval(() => {
    // 该定时器实际会在 3s 后立即触发下一次回调
    // 执行完这里的代码需要 2s
  }, 1000)
  let doSometing = () => {
    // 使用 setTimeout 改写，4秒后触发下一次回调
    // 执行完这里的代码需要 2s
    setTimeout(doSometing, 1000)
  }
  doSometing()
  ```

## 10.for in 问题

- 常规操作没有问题

  ```js
  let arr = [1, 2]
  for (let key in arr) {
    console.log(arr[key]) // 会正常打印 1, 2
  }
  ```

  ::: warning 注意

  - 添加自定义属性，会有问题

    ```js
    Array.prototype.test = function() {} // 在 Array 原型链上添加一个方法
    for (let key in arr) {
      console.log(arr[key]) // 此时会打印 1, 2, ƒ () {}
    }
    ```

    因为我们不能保证项目代码中不会对数组原型链进行操作，也不能保证引入的第三方库不对其进行操作，所以不要使用 for in 循环来遍历数组。
  :::

## 11.清除定时器

  ```js
  export default {
    methods: {
      fun1() {
        const timer = setInterval(() => {
          console.log("1") //具体执行代码
        }, 1000)
        this.$once("hook:beforeDestory", () => {
          clearInterval(timer)
          timer = null
        })
      },
    },
  }
  ```
