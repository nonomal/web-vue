---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: Vue2.x 源码
  - name: 源码入口
    content: Vue2.x 源码入口的相关逻辑
---

# 源码入口

::: tip 前言
Vue 在代码中引入使用前，会主要通过两步生成`Vue`构造函数：1.创建 Vue 构造函数，2.添加原型方法和属性，3.添加私有方法和属性
:::

- 工程项目中引入之前`vue`内部会创建一个 Vue 的构造函数

  ```js
  import Vue from "vue"
  ```

## 1.创建 Vue 类

- `new vue`时进入这里进行组件的初始化操作，调用访问各种准备好的属性和方法

  ```js
  function Vue(options) {
    this._init(options)
  }
  ```

## 2.原型扩展

- 分类添加

  ```js
  initMixin(Vue)
  stateMixin(Vue)
  eventsMixin(Vue)
  lifecycleMixin(Vue)
  renderMixin(Vue)
  ```

### 2.1 initMixin

- 初始化时在原型上混入初始化函数，当实例化 Vue 时，会调用初始化方法，从而依次执行里面的相关属性和方法。

  ```js
  export function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      const vm: Component = this
      vm._uid = uid++
      let startTag, endTag
      vm._isVue = true
      if (options && options._isComponent) {
        initInternalComponent(vm, options) // 继承子组件时会初始化组件调用组件的初始化方法
      } else {
        vm.$options = mergeOptions(
          resolveConstructorOptions(vm.constructor), //合并配置
          options || {},
          vm
        )
      }
      vm._renderProxy = vm
      vm._self = vm
      initLifecycle(vm) // 初始化生命周期
      initEvents(vm) // 初始化事件
      initRender(vm) // 初始化渲染函数
      callHook(vm, "beforeCreate") //调用生命周期 beforeCreate
      initInjections(vm) // 初始化inject函数
      initState(vm) // 初始化响应式数据
      initProvide(vm) // 初始化provide函数
      callHook(vm, "created") // 调用生命周期 created
      if (vm.$options.el) {
        vm.$mount(vm.$options.el) //挂载组件
      }
    }
  }
  ```

### 2.2 stateMixin

- Vue 初始化时，在 Vue 的原型上添加响应式相关的函数，在 Vue 运行时内部 this 可以调用相关原型上的方法

  ```js
  export function stateMixin(Vue: Class<Component>) {
    const dataDef = {}
    dataDef.get = function () {
      return this._data // data数据添加get方法，通过this获取data中的数据时会被这里的函数拦截返回数据
    }
    const propsDef = {}
    propsDef.get = function () {
      return this._props
    }

    Object.defineProperty(Vue.prototype, "$data", dataDef)
    Object.defineProperty(Vue.prototype, "$props", propsDef)

    Vue.prototype.$set = set
    Vue.prototype.$delete = del

    Vue.prototype.$watch = function (
      expOrFn: string | Function,
      cb: any,
      options?: Object
    ): Function {
      const vm: Component = this
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options)
      }
      options = options || {}
      options.user = true
      const watcher = new Watcher(vm, expOrFn, cb, options)
      if (options.immediate) {
        cb.call(vm, watcher.value)
      }
      return function unwatchFn() {
        watcher.teardown()
      }
    }
  }
  ```

### 2.3 eventsMixin

- 初始化时，在 Vue 原型上扩展相关的事件方法

  ```js
  export function eventsMixin(Vue) {
    const hookRE = /^hook:/
    Vue.prototype.$on = function (event, fn) {
      const vm = this
      if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i < l; i++) {
          this.$on(event[i], fn)
        }
      } else {
        ;(vm._events[event] || (vm._events[event] = [])).push(fn)

        if (hookRE.test(event)) {
          vm._hasHookEvent = true
        }
      }
      return vm
    }
    Vue.prototype.$once = function (event, fn) {
      const vm = this
      function on() {
        vm.$off(event, on)
        fn.apply(vm, arguments)
      }
      on.fn = fn
      vm.$on(event, on)
      return vm
    }
    Vue.prototype.$off = function (event, fn) {
      const vm = this
      if (!arguments.length) {
        vm._events = Object.create(null)
        return vm
      }
      if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i < l; i++) {
          this.$off(event[i], fn)
        }
        return vm
      }
      const cbs = vm._events[event]
      if (!cbs) {
        return vm
      }
      if (!fn) {
        vm._events[event] = null
        return vm
      }
      if (fn) {
        let cb
        let i = cbs.length
        while (i--) {
          cb = cbs[i]
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i, 1)
            break
          }
        }
      }
      return vm
    }
    Vue.prototype.$emit = function (event) {
      const vm = this
      let cbs = vm._events[event]
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs
        const args = toArray(arguments, 1)
        for (let i = 0, l = cbs.length; i < l; i++) {
          try {
            cbs[i].apply(vm, args)
          } catch (e) {
            handleError(e, vm, `event handler for "${event}"`)
          }
        }
      }
      return vm
    }
  }
  ```

### 2.4 lifecycleMixin

- 初始化时在原型上扩展相关生命周期的方法，可以在 Vue 运行时 this 上使用

  ```js
  export function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      const vm = this
      if (vm._isMounted) {
        callHook(vm, "beforeUpdate")
      }
      const prevEl = vm.$el
      const prevVnode = vm._vnode
      const prevActiveInstance = activeInstance
      activeInstance = vm
      vm._vnode = vnode
      if (!prevVnode) {
        vm.$el = vm.__patch__(
          vm.$el,
          vnode,
          hydrating,
          false,
          vm.$options._parentElm,
          vm.$options._refElm
        )
        vm.$options._parentElm = vm.$options._refElm = null
      } else {
        vm.$el = vm.__patch__(prevVnode, vnode)
      }
      activeInstance = prevActiveInstance
      if (prevEl) {
        prevEl.__vue__ = null
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm
      }
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el
      }
    }
    Vue.prototype.$forceUpdate = function () {
      const vm = this
      if (vm._watcher) {
        vm._watcher.update()
      }
    }
    Vue.prototype.$destroy = function () {
      const vm = this
      if (vm._isBeingDestroyed) {
        return
      }
      callHook(vm, "beforeDestroy")
      vm._isBeingDestroyed = true
      const parent = vm.$parent
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm)
      }
      if (vm._watcher) {
        vm._watcher.teardown()
      }
      let i = vm._watchers.length
      while (i--) {
        vm._watchers[i].teardown()
      }
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--
      }
      vm._isDestroyed = true
      vm.__patch__(vm._vnode, null)
      callHook(vm, "destroyed")
      vm.$off()
      if (vm.$el) {
        vm.$el.__vue__ = null
      }
      if (vm.$vnode) {
        vm.$vnode.parent = null
      }
    }
  }
  ```

### 2.5 renderMixin

- Vue 初始化时在原型上扩展渲染相关的函数，可以在 Vue 运行时在 this 上访问这些方法

  ```js
  export function renderMixin(Vue) {
    installRenderHelpers(Vue.prototype)
    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this)
    }
    Vue.prototype._render = function () {
      const vm = this
      const { render, _parentVnode } = vm.$options
      if (process.env.NODE_ENV !== "production") {
        for (const key in vm.$slots) {
          vm.$slots[key]._rendered = false
        }
      }
      if (_parentVnode) {
        vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject
      }
      vm.$vnode = _parentVnode
      let vnode
      try {
        vnode = render.call(vm._renderProxy, vm.$createElement)
      } catch (e) {
        handleError(e, vm, `render`)
        vnode = vm._vnode
      }
      if (!(vnode instanceof VNode)) {
        vnode = createEmptyVNode()
      }
      vnode.parent = _parentVnode
      return vnode
    }
  }
  ```

## 3.私有扩展

- 通过`initGlobalAPI(Vue)`实现在 Vue 上添加私有属性和方法

  ```js
  initGlobalAPI(Vue)
  ```

- `initGlobalAPI`函数
  ```js
  export function initGlobalAPI(Vue) {
    const configDef = {}
    configDef.get = () => config
    Object.defineProperty(Vue, "config", configDef)
    Vue.util = {
      warn,
      extend,
      mergeOptions,
      defineReactive,
    }
    Vue.set = set
    Vue.delete = del
    Vue.nextTick = nextTick
    Vue.options = Object.create(null)
    ASSET_TYPES.forEach((type) => {
      Vue.options[type + "s"] = Object.create(null)
    })
    Vue.options._base = Vue
    extend(Vue.options.components, builtInComponents)
    initUse(Vue)
    initMixin(Vue)
    initExtend(Vue)
    initAssetRegisters(Vue)
  }
  ```

### 3.1 initUse

::: tip 提示
在 Vue 上添加私有方法：initUse 加载插件
:::

```js
function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins =
      this._installedPlugins || (this._installedPlugins = [])
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }
    var args = toArray(arguments, 1)
    args.unshift(this)
    if (isFunction(plugin.install)) {
      plugin.install.apply(plugin, args)
    } else if (isFunction(plugin)) {
      plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this
  }
}
```

### 3.2 initMixin

```js
function initMixin(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
```

### 3.3 initExtend

::: tip 提示
在 Vue 上添加私有方法：extend 继承子类
:::

```js
function initExtend(Vue) {
  Vue.cid = 0
  var cid = 1
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {}
    var Super = this
    var SuperId = Super.cid
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }
    var name =
      getComponentName(extendOptions) || getComponentName(Super.options)
    if (name) {
      validateComponentName(name)
    }
    var Sub = function VueComponent(options) {
      this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(Super.options, extendOptions)
    Sub["super"] = Super
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    if (name) {
      Sub.options.components[name] = Sub
    }
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)
    cachedCtors[SuperId] = Sub
    return Sub
  }
}
```

### 3.4 initAssetRegisters

::: tip 提示
在 Vue 上添加私有方法：component、directive、filter
:::

```js
function initAssetRegisters(Vue) {
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + "s"][id]
      } else {
        if (type === "component") {
          validateComponentName(id)
        }
        if (type === "component" && isPlainObject(definition)) {
          definition.name = definition.name || id
          definition = this.options._base.extend(definition)
        }
        if (type === "directive" && isFunction(definition)) {
          definition = { bind: definition, update: definition }
        }
        this.options[type + "s"][id] = definition
        return definition
      }
    }
  })
}
```

## 4.其他

- 添加挂载函数，重写挂载函数
- 添加编译函数

### 4.1 $mount

```js
Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

```js
function mountComponent(vm, el, hydrating) {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    {
      if (
        (vm.$options.template && vm.$options.template.charAt(0) !== "#") ||
        vm.$options.el ||
        el
      ) {
        warn$2(
          "You are using the runtime-only build of Vue where the template " +
            "compiler is not available. Either pre-compile the templates into " +
            "render functions, or use the compiler-included build.",
          vm
        )
      } else {
        warn$2(
          "Failed to mount component: template or render function not defined.",
          vm
        )
      }
    }
  }
  callHook$1(vm, "beforeMount")
  var updateComponent
  updateComponent = function () {
    vm._update(vm._render(), hydrating)
  }
  var watcherOptions = {
    before: function () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook$1(vm, "beforeUpdate")
      }
    },
  }
  {
    watcherOptions.onTrack = function (e) {
      return callHook$1(vm, "renderTracked", [e])
    }
    watcherOptions.onTrigger = function (e) {
      return callHook$1(vm, "renderTriggered", [e])
    }
  }
  new Watcher(vm, updateComponent, noop, watcherOptions, true)
  hydrating = false
  var preWatchers = vm._preWatchers
  if (preWatchers) {
    for (var i = 0; i < preWatchers.length; i++) {
      preWatchers[i].run()
    }
  }
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook$1(vm, "mounted")
  }
  return vm
}
```

```js
Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el)
  if (el === document.body || el === document.documentElement) {
    warn$2(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    )
    return this
  }
  var options = this.$options
  if (!options.render) {
    var template = options.template
    if (template) {
      if (typeof template === "string") {
        if (template.charAt(0) === "#") {
          template = idToTemplate(template)
          if (!template) {
            warn$2(
              "Template element not found or is empty: ".concat(
                options.template
              ),
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        {
          warn$2("invalid template option:" + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      if (config.performance && mark) {
        mark("compile")
      }
      var _a = compileToFunctions(
          template,
          {
            outputSourceRange: true,
            shouldDecodeNewlines: shouldDecodeNewlines,
            shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
            delimiters: options.delimiters,
            comments: options.comments,
          },
          this
        ),
        render = _a.render,
        staticRenderFns = _a.staticRenderFns
      options.render = render
      options.staticRenderFns = staticRenderFns
      if (config.performance && mark) {
        mark("compile end")
        measure("vue ".concat(this._name, " compile"), "compile", "compile end")
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

### 4.2 compiler

```js
Vue.compile = compileToFunctions
```

```js
function createCompileToFunctionFn(compile) {
  var cache = Object.create(null)
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options)
    var warn = options.warn || warn$2
    delete options.warn
    {
      try {
        new Function("return 1")
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn(
            "It seems you are using the standalone build of Vue.js in an " +
              "environment with Content Security Policy that prohibits unsafe-eval. " +
              "The template compiler cannot work in this environment. Consider " +
              "relaxing the policy to allow unsafe-eval or pre-compiling your " +
              "templates into render functions."
          )
        }
      }
    }
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }
    var compiled = compile(template, options)
    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn(
              "Error compiling template:\n\n".concat(e.msg, "\n\n") +
                generateCodeFrame(template, e.start, e.end),
              vm
            )
          })
        } else {
          warn(
            "Error compiling template:\n\n".concat(template, "\n\n") +
              compiled.errors
                .map(function (e) {
                  return "- ".concat(e)
                })
                .join("\n") +
              "\n",
            vm
          )
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm)
          })
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm)
          })
        }
      }
    }
    var res = {}
    var fnGenErrors = []
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    })
    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn(
          "Failed to generate render function:\n\n" +
            fnGenErrors
              .map(function (_a) {
                var err = _a.err,
                  code = _a.code
                return "".concat(err.toString(), " in\n\n").concat(code, "\n")
              })
              .join("\n"),
          vm
        )
      }
    }
    return (cache[key] = res)
  }
}

function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions)
      var errors = []
      var tips = []
      var warn = function (msg, range, tip) {
        ;(tip ? tips : errors).push(msg)
      }
      if (options) {
        if (options.outputSourceRange) {
          var leadingSpaceLength_1 = template.match(/^\s*/)[0].length
          warn = function (msg, range, tip) {
            var data = typeof msg === "string" ? { msg: msg } : msg
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength_1
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength_1
              }
            }
            ;(tip ? tips : errors).push(data)
          }
        }
        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(
            options.modules
          )
        }
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        for (var key in options) {
          if (key !== "modules" && key !== "directives") {
            finalOptions[key] = options[key]
          }
        }
      }
      finalOptions.warn = warn
      var compiled = baseCompile(template.trim(), finalOptions)
      {
        detectErrors(compiled.ast, warn)
      }
      compiled.errors = errors
      compiled.tips = tips
      return compiled
    }
    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile),
    }
  }
}
```

### 4.3 patch

```js
Vue.prototype.__patch__ = inBrowser ? patch : noop
```

```js
var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules$1 })
```

```js
function createPatchFunction(backend) {
  var i, j
  var cbs = {}
  var modules = backend.modules,
    nodeOps = backend.nodeOps
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = []
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
  }
  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }
  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm)
      }
    }
    remove.listeners = listeners
    return remove
  }
  function removeNode(el) {
    var parent = nodeOps.parentNode(el)
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el)
    }
  }
  function isUnknownElement(vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }
  var creatingElmInVPre = 0
  function createElm(
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index] = cloneVNode(vnode)
    }
    vnode.isRootInsert = !nested
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }
    var data = vnode.data
    var children = vnode.children
    var tag = vnode.tag
    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++
        }
        if (isUnknownElement(vnode, creatingElmInVPre)) {
          warn$2(
            "Unknown custom element: <" +
              tag +
              "> - did you " +
              "register the component correctly? For recursive components, " +
              'make sure to provide the "name" option.',
            vnode.context
          )
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode)
      createChildren(vnode, children, insertedVnodeQueue)
      if (isDef(data)) {
        invokeCreateHooks(vnode, insertedVnodeQueue)
      }
      insert(parentElm, vnode.elm, refElm)
      if (data && data.pre) {
        creatingElmInVPre--
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    }
  }
  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive
      if (isDef((i = i.hook)) && isDef((i = i.init))) {
        i(vnode, false)
      }
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue)
        insert(parentElm, vnode.elm, refElm)
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
        }
        return true
      }
    }
  }
  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(
        insertedVnodeQueue,
        vnode.data.pendingInsert
      )
      vnode.data.pendingInsert = null
    }
    vnode.elm = vnode.componentInstance.$el
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue)
      setScope(vnode)
    } else {
      registerRef(vnode)
      insertedVnodeQueue.push(vnode)
    }
  }
  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i
    var innerNode = vnode
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode
      if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode)
        }
        insertedVnodeQueue.push(innerNode)
        break
      }
    }
    insert(parentElm, vnode.elm, refElm)
  }
  function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        if (nodeOps.parentNode(ref) === parent) {
          nodeOps.insertBefore(parent, elm, ref)
        }
      } else {
        nodeOps.appendChild(parent, elm)
      }
    }
  }
  function createChildren(vnode, children, insertedVnodeQueue) {
    if (isArray(children)) {
      {
        checkDuplicateKeys(children)
      }
      for (var i_1 = 0; i_1 < children.length; ++i_1) {
        createElm(
          children[i_1],
          insertedVnodeQueue,
          vnode.elm,
          null,
          true,
          children,
          i_1
        )
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))
    }
  }
  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode
    }
    return isDef(vnode.tag)
  }
  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
      cbs.create[i_2](emptyNode, vnode)
    }
    i = vnode.data.hook
    if (isDef(i)) {
      if (isDef(i.create)) i.create(emptyNode, vnode)
      if (isDef(i.insert)) insertedVnodeQueue.push(vnode)
    }
  }
  function setScope(vnode) {
    var i
    if (isDef((i = vnode.fnScopeId))) {
      nodeOps.setStyleScope(vnode.elm, i)
    } else {
      var ancestor = vnode
      while (ancestor) {
        if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
          nodeOps.setStyleScope(vnode.elm, i)
        }
        ancestor = ancestor.parent
      }
    }
    if (
      isDef((i = activeInstance)) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef((i = i.$options._scopeId))
    ) {
      nodeOps.setStyleScope(vnode.elm, i)
    }
  }
  function addVnodes(
    parentElm,
    refElm,
    vnodes,
    startIdx,
    endIdx,
    insertedVnodeQueue
  ) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(
        vnodes[startIdx],
        insertedVnodeQueue,
        parentElm,
        refElm,
        false,
        vnodes,
        startIdx
      )
    }
  }
  function invokeDestroyHook(vnode) {
    var i, j
    var data = vnode.data
    if (isDef(data)) {
      if (isDef((i = data.hook)) && isDef((i = i.destroy))) i(vnode)
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode)
    }
    if (isDef((i = vnode.children))) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j])
      }
    }
  }
  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx]
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch)
          invokeDestroyHook(ch)
        } else {
          removeNode(ch.elm)
        }
      }
    }
  }
  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i_3
      var listeners = cbs.remove.length + 1
      if (isDef(rm)) {
        rm.listeners += listeners
      } else {
        rm = createRmCb(vnode.elm, listeners)
      }
      if (
        isDef((i_3 = vnode.componentInstance)) &&
        isDef((i_3 = i_3._vnode)) &&
        isDef(i_3.data)
      ) {
        removeAndInvokeRemoveHook(i_3, rm)
      }
      for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
        cbs.remove[i_3](vnode, rm)
      }
      if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {
        i_3(vnode, rm)
      } else {
        rm()
      }
    } else {
      removeNode(vnode.elm)
    }
  }
  function updateChildren(
    parentElm,
    oldCh,
    newCh,
    insertedVnodeQueue,
    removeOnly
  ) {
    var oldStartIdx = 0
    var newStartIdx = 0
    var oldEndIdx = oldCh.length - 1
    var oldStartVnode = oldCh[0]
    var oldEndVnode = oldCh[oldEndIdx]
    var newEndIdx = newCh.length - 1
    var newStartVnode = newCh[0]
    var newEndVnode = newCh[newEndIdx]
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm
    var canMove = !removeOnly
    {
      checkDuplicateKeys(newCh)
    }
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx]
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(
          oldStartVnode,
          newStartVnode,
          insertedVnodeQueue,
          newCh,
          newStartIdx
        )
        oldStartVnode = oldCh[++oldStartIdx]
        newStartVnode = newCh[++newStartIdx]
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(
          oldEndVnode,
          newEndVnode,
          insertedVnodeQueue,
          newCh,
          newEndIdx
        )
        oldEndVnode = oldCh[--oldEndIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(
          oldStartVnode,
          newEndVnode,
          insertedVnodeQueue,
          newCh,
          newEndIdx
        )
        canMove &&
          nodeOps.insertBefore(
            parentElm,
            oldStartVnode.elm,
            nodeOps.nextSibling(oldEndVnode.elm)
          )
        oldStartVnode = oldCh[++oldStartIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(
          oldEndVnode,
          newStartVnode,
          insertedVnodeQueue,
          newCh,
          newStartIdx
        )
        canMove &&
          nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode = oldCh[--oldEndIdx]
        newStartVnode = newCh[++newStartIdx]
      } else {
        if (isUndef(oldKeyToIdx))
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
        if (isUndef(idxInOld)) {
          createElm(
            newStartVnode,
            insertedVnodeQueue,
            parentElm,
            oldStartVnode.elm,
            false,
            newCh,
            newStartIdx
          )
        } else {
          vnodeToMove = oldCh[idxInOld]
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(
              vnodeToMove,
              newStartVnode,
              insertedVnodeQueue,
              newCh,
              newStartIdx
            )
            oldCh[idxInOld] = undefined
            canMove &&
              nodeOps.insertBefore(
                parentElm,
                vnodeToMove.elm,
                oldStartVnode.elm
              )
          } else {
            createElm(
              newStartVnode,
              insertedVnodeQueue,
              parentElm,
              oldStartVnode.elm,
              false,
              newCh,
              newStartIdx
            )
          }
        }
        newStartVnode = newCh[++newStartIdx]
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
      addVnodes(
        parentElm,
        refElm,
        newCh,
        newStartIdx,
        newEndIdx,
        insertedVnodeQueue
      )
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx)
    }
  }
  function checkDuplicateKeys(children) {
    var seenKeys = {}
    for (var i_4 = 0; i_4 < children.length; i_4++) {
      var vnode = children[i_4]
      var key = vnode.key
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn$2(
            "Duplicate keys detected: '".concat(
              key,
              "'. This may cause an update error."
            ),
            vnode.context
          )
        } else {
          seenKeys[key] = true
        }
      }
    }
  }
  function findIdxInOld(node, oldCh, start, end) {
    for (var i_5 = start; i_5 < end; i_5++) {
      var c = oldCh[i_5]
      if (isDef(c) && sameVnode(node, c)) return i_5
    }
  }
  function patchVnode(
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index] = cloneVNode(vnode)
    }
    var elm = (vnode.elm = oldVnode.elm)
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
      } else {
        vnode.isAsyncPlaceholder = true
      }
      return
    }
    if (
      isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance
      return
    }
    var i
    var data = vnode.data
    if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
      i(oldVnode, vnode)
    }
    var oldCh = oldVnode.children
    var ch = vnode.children
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
      if (isDef((i = data.hook)) && isDef((i = i.update))) i(oldVnode, vnode)
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch)
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch)
        }
        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, "")
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1)
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, "")
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text)
    }
    if (isDef(data)) {
      if (isDef((i = data.hook)) && isDef((i = i.postpatch))) i(oldVnode, vnode)
    }
  }
  function invokeInsertHook(vnode, queue, initial) {
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue
    } else {
      for (var i_6 = 0; i_6 < queue.length; ++i_6) {
        queue[i_6].data.hook.insert(queue[i_6])
      }
    }
  }
  var hydrationBailed = false
  var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key")
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i
    var tag = vnode.tag,
      data = vnode.data,
      children = vnode.children
    inVPre = inVPre || (data && data.pre)
    vnode.elm = elm
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true
      return true
    }
    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef((i = data.hook)) && isDef((i = i.init))) i(vnode, true)
      if (isDef((i = vnode.componentInstance))) {
        initComponent(vnode, insertedVnodeQueue)
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue)
        } else {
          if (
            isDef((i = data)) &&
            isDef((i = i.domProps)) &&
            isDef((i = i.innerHTML))
          ) {
            if (i !== elm.innerHTML) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true
                console.warn("Parent: ", elm)
                console.warn("server innerHTML: ", i)
                console.warn("client innerHTML: ", elm.innerHTML)
              }
              return false
            }
          } else {
            var childrenMatch = true
            var childNode = elm.firstChild
            for (var i_7 = 0; i_7 < children.length; i_7++) {
              if (
                !childNode ||
                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)
              ) {
                childrenMatch = false
                break
              }
              childNode = childNode.nextSibling
            }
            if (!childrenMatch || childNode) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true
                console.warn("Parent: ", elm)
                console.warn(
                  "Mismatching childNodes vs. VNodes: ",
                  elm.childNodes,
                  children
                )
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true
            invokeCreateHooks(vnode, insertedVnodeQueue)
            break
          }
        }
        if (!fullInvoke && data["class"]) {
          traverse(data["class"])
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text
    }
    return true
  }
  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf("vue-component") === 0 ||
        (!isUnknownElement(vnode, inVPre) &&
          vnode.tag.toLowerCase() ===
            (node.tagName && node.tagName.toLowerCase()))
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }
  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }
    var isInitialPatch = false
    var insertedVnodeQueue = []
    if (isUndef(oldVnode)) {
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      var isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else {
              warn$2(
                "The client-side rendered virtual DOM tree is not matching " +
                  "server-rendered content. This is likely caused by incorrect " +
                  "HTML markup, for example nesting block-level elements inside " +
                  "<p>, or missing <tbody>. Bailing hydration and performing " +
                  "full client-side render."
              )
            }
          }
          oldVnode = emptyNodeAt(oldVnode)
        }
        var oldElm = oldVnode.elm
        var parentElm = nodeOps.parentNode(oldElm)
        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent
          var patchable = isPatchable(vnode)
          while (ancestor) {
            for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
              cbs.destroy[i_8](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
                cbs.create[i_9](emptyNode, ancestor)
              }
              var insert_1 = ancestor.data.hook.insert
              if (insert_1.merged) {
                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {
                  insert_1.fns[i_10]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }
        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }
    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
}
```
