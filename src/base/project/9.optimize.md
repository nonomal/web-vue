---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 九.项目优化

## 1.预渲染

```bash
npm i prerender-spa-plugin
```

缺陷数据不够动态，可以使用 ssr 服务端渲染

```js
const PrerenderSPAPlugin = require("prerender-spa-plugin")
const path = require("path")
module.exports = {
  configureWebpack: {
    plugins: [
      new PrerenderSPAPlugin({
        staticDir: path.join(__dirname, "dist"),
        routes: ["/", "/about"],
      }),
    ],
  },
}
```

## 2.骨架屏

配置 webpack 插件 vue-skeleton-webpack-plugin

单页骨架屏幕

```js
import Vue from "vue"
import Skeleton from "./Skeleton.vue"
export default new Vue({
  components: {
    Skeleton: Skeleton,
  },
  template: `
        <Skeleton></Skeleton>    
    `,
})
// 骨架屏
plugins: [
  new SkeletonWebpackPlugin({
    webpackConfig: {
      entry: {
        app: resolve("./src/entry-skeleton.js"),
      },
    },
  }),
]
```

带路由的骨架屏，编写 skeleton.js 文件

```js
import Vue from "vue"
import Skeleton1 from "./Skeleton1"
import Skeleton2 from "./Skeleton2"

export default new Vue({
  components: {
    Skeleton1,
    Skeleton2,
  },
  template: `
        <div>
            <skeleton1 id="skeleton1" style="display:none"/>
            <skeleton2 id="skeleton2" style="display:none"/>
        </div>
    `,
})
```

```js
new SkeletonWebpackPlugin({
  webpackConfig: {
    entry: {
      app: path.join(__dirname, "./src/skeleton.js"),
    },
  },
  router: {
    mode: "history",
    routes: [
      {
        path: "/",
        skeletonId: "skeleton1",
      },
      {
        path: "/about",
        skeletonId: "skeleton2",
      },
    ],
  },
  minimize: true,
  quiet: true,
})
```

> 优化白屏效果
> 实现骨架屏插件

```js
class MyPlugin {
  apply(compiler) {
    compiler.plugin("compilation", (compilation) => {
      compilation.plugin(
        "html-webpack-plugin-before-html-processing",
        (data) => {
          data.html = data.html.replace(
            `<div id="app"></div>`,
            `
            <div id="app">
                <div id="home" style="display:none">首页 骨架屏</div>
                <div id="about" style="display:none">about页面骨架屏</div>
            </div>
            <script>
                if(window.hash == '#/about' ||  location.pathname=='/about'){
                    document.getElementById('about').style.display="block"
                }else{
                    document.getElementById('home').style.display="block"
                }
            </script>
            `
          )
          return data
        }
      )
    })
  }
}
```

## 3.服务端渲染

概念：放在浏览器进行就是浏览器渲染,放在服务器进行就是服务器渲染。

- 客户端渲染不利于 SEO 搜索引擎优化
- 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的
- SSR 直接将 HTML 字符串传递给浏览器。大大加快了首屏加载时间。
- SSR 占用更多的 CPU 和内存资源
- 一些常用的浏览器 API 可能无法正常使用
- 在 vue 中只支持 beforeCreate 和 created 两个生命周期
- Nuxt.js 是使用 Webpack 和 Node.js 进行封装的基于 Vue 的 SSR 框架


::: tip 前言
在 Vue 中，页面都可以看作是由大大小小的模块构成的，即便是一行代码、一个函数、一个组件都可以看作是一个个自由的模块。那么提高代码的复用性的关键便在于编写可复用的模块，也就是编写可复用的代码、函数和组件等。
:::
## 1.复用代码

使用变量的赋值缓存使用来解决数据的重复

> ```js {4}
> let person = []
> for (let i = 0; i < data.obj.items.length; i++) {
>   person.push({
>     name: data.obj.items[i].name, // 出现了重复性的代码片段 data.obj.items
>     age: data.obj.items[i].age,
>   })
> }
> ```
>
> 上述代码一旦需要修改变量 `items` 为 `lists`，那么我们就得修改 3 处地方，不知不觉就增加了维护成本
>
> ```js {2}
> let person = []
> let values = data.obj.items // 通过变量 values 实现了复用，不管是维护成本还是代码可读性上，复用的优势都显而易见
> for (let i = 0; i < values.length; i++) {
>   person.push({
>     name: values[i].name,
>     age: values[i].age,
>   })
> }
> ```

## 2.函数封装

使用公共方法来解决功能的重复

> ```js {5,6}
> <tempalte>
>    <div>
>        <input type="text" v-model="str1">
>        <input type="text" v-model="str2">
>        <div>{{ str1.slice(1).toUpperCase() }}</div>
>        <div>{{ str2.slice(1).toUpperCase() }}</div> // toUpperCase，大写字母转化功能点的重复
>    </div>
> </template>
> ```
>
> 重复书写相同功能的代码是一种不经过大脑思考的行为，我们需要对其进行优化，这里我们可以把功能点封装成一个函数,在用到该方法的地方调用即可
>
> ```js
> export default {
>   methods: {
>     sliceUpperCase(val) {
>       return val.slice(1).toUpperCase()
>     },
>   },
> }
> ```

像在双花括号插值和 v-bind 表达式中重复的功能点，我们可以封装成过滤器使用更加合适

> ```js
> // 单文件组件注册过滤器
> filters: {
>    sliceUpperCase(val) {
>        return val.slice(1).toUpperCase()
>    }
> }
> // 全局注册过滤器
> Vue.filter('sliceUpperCase', function (val) {
>    return val.slice(1).toUpperCase()
> })
> ```
>
> 然后在 模板 中使用“管道”符进行过滤：
>
> ```js
> <div>{{ str1 | toUpperCase }}</div>
> <div>{{ str2 | toUpperCase }}</div>
> ```

这样我们就把重复的功能性代码封装成了函数，而不管是过滤器还是正常的方法封装，其本质都是函数的封装。

## 3.组件封装

相比较于函数的封装，规模更大一点的便是组件的封装，组件包含了模板、脚本以及样式的代码，在实际开发中组件的使用频率也是非常大的，我们项目中的每一个页面其实都可以看作是一个父组件，其可以包含很多子组件，子组件通过接收父组件的值来渲染页面，父组件通过响应子组件的回调来触发事件。

封装一个组件主要包含两种方式，一种是最常见的整体封装，用户通过改变数据源来呈现不同的页面状态，代码结构不可定制化。例如：

```js
<div>
  <my-component data="我是父组件传入子组件的数据"></my-component>
</div>
```

另一种便是自定义封装，也就是插槽(slot)，我们可以开放一部分槽位给父组件，使其能够进行一定程度的定制化，例如：

```js
<div>
  <my-component data="我是父组件传入子组件的数据">
    <template slot="customize">
      <span>这是定制化的数据</span>
    </template>
  </my-component>
</div>
```

在 myComponent 组件中我们便可以接收对应的 slot：

```js
<div class="container">
    <span>{{ data }}</span>
    <slot name="customize"></slot>
<div>
```

这里我们通过定义 slot 标签的 name 值为 customize 来接收父组件在使用该组件时在 template 标签上定义的 slot="customize" 中的代码，不同父组件可以定制不同的 slot 代码来实现差异化的插槽。最终渲染出来的代码如下：

```js
<div>
  <div class="container">
    <span>我是父组件传入子组件的数据</span>
    <span>这是定制化的数据</span>
  </div>
</div>
```

这样我们就完成了一个小型组件的封装，将共用代码封装到组件中去，页面需要引入的时候直接使用 import 并进行相应注册即可，当然你也可以进行全局的引入：

```js
import myComponent from "../myComponent.vue"
// 全局
Vue.component("my-component", myComponent)
```

## 4.插件封装

在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 api 即可，这需要我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 loading 功能、弹框功能等。

> 编写插件
>
> ```js
> /* toast.js */
> import ToastComponent from "./toast.vue" // 引入组件
> let $vm
> export default {
>   install(Vue, options) {
>     if (!$vm) {
>       const ToastPlugin = Vue.extend(ToastComponent) // 创建一个“扩展实例构造器”
>       $vm = new ToastPlugin({
>         el: document.createElement("div"), // 声明挂载元素
>       })
>       document.body.appendChild($vm.$el) // 把 toast 组件的 DOM 添加到 body 里
>     }
>     let toast = (text, duration) => {
>       // 给 toast 设置自定义文案和时间
>       $vm.text = text
>       $vm.duration = duration
>       setTimeout(() => {
>         // 在指定 duration 之后让 toast 消失
>         $vm.isShow = false
>       }, $vm.duration)
>     }
>     if (!Vue.$toast) {
>       // 判断 Vue.$toast 是否存在
>       Vue.$toast = toast
>     }
>     Vue.prototype.$toast = Vue.$toast // 全局添加 $toast 事件
>   },
> }
> ```
>
> 注册插件
>
> ```js
> import Toast from "@/widgets/toast/toast.js"
> Vue.use(Toast) // 注册 Toast
> ```
>
> 使用插件
>
> ```js
> this.$toast("Hello World", 2000)
> ```

当然你也可以不使用 install 方法来编写插件，直接采用导出一个封装好的实例方法并将其挂载到 Vue 的原型链上来实现相同的功能。
