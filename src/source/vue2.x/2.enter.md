---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: Vue2.x 源码
  - name: 源码入口
    content: Vue2.x 源码入口的相关逻辑
---

# 源码入口

::: tip 前言
Vue 在代码中引入使用前，会主要通过两步生成`Vue`构造函数：1.创建 Vue 构造函数，2.添加原型方法和属性，3.添加私有方法和属性
:::

- 工程项目中引入之前`vue`内部会创建一个 Vue 的构造函数

  ```js
  import Vue from "vue"
  ```

## 1.创建 Vue 类

- `new vue`时进入这里进行组件的初始化操作，调用访问各种准备好的属性和方法

- /src/vue/src/core/instance/index.ts

<<< @/src/vue/src/core/instance/index.ts#snippet1

## 2.原型扩展

- /src/vue/src/core/instance/index.ts

<<< @/src/vue/src/core/instance/index.ts#snippet2

### 2.1 initMixin

- 初始化时在原型上混入初始化函数，当实例化 Vue 时，会调用初始化方法，从而依次执行里面的相关属性和方法。

- /src/vue/src/core/instance/init.ts

<<< @/src/vue/src/core/instance/init.ts#snippet1

### 2.2 stateMixin

- Vue 初始化时，在 Vue 的原型上添加响应式相关的函数，在 Vue 运行时内部 this 可以调用相关原型上的方法

- /src/vue/src/core/instance/state.ts

<<< @/src/vue/src/core/instance/state.ts#snippet1

### 2.3 eventsMixin

- 初始化时，在 Vue 原型上扩展相关的事件方法

- /src/vue/src/core/instance/events.ts

<<< @/src/vue/src/core/instance/events.ts#snippet1

### 2.4 lifecycleMixin

- 初始化时在原型上扩展相关生命周期的方法，可以在 Vue 运行时 this 上使用

- /src/vue/src/core/instance/lifecycle.ts

<<< @/src/vue/src/core/instance/lifecycle.ts#snippet1

### 2.5 renderMixin

- Vue 初始化时在原型上扩展渲染相关的函数，可以在 Vue 运行时在 this 上访问这些方法

- /src/vue/src/core/instance/render.ts

<<< @/src/vue/src/core/instance/render.ts#snippet1

## 3.私有扩展

- 通过`initGlobalAPI(Vue)`实现在 Vue 上添加私有属性和方法

- /src/vue/src/core/index.ts

<<< @/src/vue/src/core/index.ts

- `initGlobalAPI`函数

- /src/vue/src/core/global-api/index.ts

<<< @/src/vue/src/core/global-api/index.ts#snippet1

### 3.1 initUse

::: tip 提示
在 Vue 上添加私有方法：initUse 加载插件
:::

- /src/vue/src/core/global-api/use.ts

<<< @/src/vue/src/core/global-api/use.ts#snippet1

### 3.2 initMixin

- /src/vue/src/core/global-api/mixin.ts

<<< @/src/vue/src/core/global-api/mixin.ts#snippet1

### 3.3 initExtend

::: tip 提示
在 Vue 上添加私有方法：extend 继承子类
:::

- /src/vue/src/core/global-api/extend.ts

<<< @/src/vue/src/core/global-api/extend.ts#snippet1

### 3.4 initAssetRegisters

::: tip 提示
在 Vue 上添加私有方法：component、directive、filter
:::

- /src/vue/src/core/global-api/assets.ts

<<< @/src/vue/src/core/global-api/assets.ts#snippet1

## 4.其他

- 添加挂载函数，重写挂载函数
- 添加编译函数

### 4.1 $mount

```js
Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

```js
function mountComponent(vm, el, hydrating) {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    {
      if (
        (vm.$options.template && vm.$options.template.charAt(0) !== "#") ||
        vm.$options.el ||
        el
      ) {
        warn$2(
          "You are using the runtime-only build of Vue where the template " +
            "compiler is not available. Either pre-compile the templates into " +
            "render functions, or use the compiler-included build.",
          vm
        )
      } else {
        warn$2(
          "Failed to mount component: template or render function not defined.",
          vm
        )
      }
    }
  }
  callHook$1(vm, "beforeMount")
  var updateComponent
  updateComponent = function () {
    vm._update(vm._render(), hydrating)
  }
  var watcherOptions = {
    before: function () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook$1(vm, "beforeUpdate")
      }
    },
  }
  {
    watcherOptions.onTrack = function (e) {
      return callHook$1(vm, "renderTracked", [e])
    }
    watcherOptions.onTrigger = function (e) {
      return callHook$1(vm, "renderTriggered", [e])
    }
  }
  new Watcher(vm, updateComponent, noop, watcherOptions, true)
  hydrating = false
  var preWatchers = vm._preWatchers
  if (preWatchers) {
    for (var i = 0; i < preWatchers.length; i++) {
      preWatchers[i].run()
    }
  }
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook$1(vm, "mounted")
  }
  return vm
}
```

```js
Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el)
  if (el === document.body || el === document.documentElement) {
    warn$2(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    )
    return this
  }
  var options = this.$options
  if (!options.render) {
    var template = options.template
    if (template) {
      if (typeof template === "string") {
        if (template.charAt(0) === "#") {
          template = idToTemplate(template)
          if (!template) {
            warn$2(
              "Template element not found or is empty: ".concat(
                options.template
              ),
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        {
          warn$2("invalid template option:" + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      if (config.performance && mark) {
        mark("compile")
      }
      var _a = compileToFunctions(
          template,
          {
            outputSourceRange: true,
            shouldDecodeNewlines: shouldDecodeNewlines,
            shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
            delimiters: options.delimiters,
            comments: options.comments,
          },
          this
        ),
        render = _a.render,
        staticRenderFns = _a.staticRenderFns
      options.render = render
      options.staticRenderFns = staticRenderFns
      if (config.performance && mark) {
        mark("compile end")
        measure("vue ".concat(this._name, " compile"), "compile", "compile end")
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

### 4.2 compiler

```js
Vue.compile = compileToFunctions
```

```js
function createCompileToFunctionFn(compile) {
  var cache = Object.create(null)
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options)
    var warn = options.warn || warn$2
    delete options.warn
    {
      try {
        new Function("return 1")
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn(
            "It seems you are using the standalone build of Vue.js in an " +
              "environment with Content Security Policy that prohibits unsafe-eval. " +
              "The template compiler cannot work in this environment. Consider " +
              "relaxing the policy to allow unsafe-eval or pre-compiling your " +
              "templates into render functions."
          )
        }
      }
    }
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }
    var compiled = compile(template, options)
    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn(
              "Error compiling template:\n\n".concat(e.msg, "\n\n") +
                generateCodeFrame(template, e.start, e.end),
              vm
            )
          })
        } else {
          warn(
            "Error compiling template:\n\n".concat(template, "\n\n") +
              compiled.errors
                .map(function (e) {
                  return "- ".concat(e)
                })
                .join("\n") +
              "\n",
            vm
          )
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm)
          })
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm)
          })
        }
      }
    }
    var res = {}
    var fnGenErrors = []
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    })
    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn(
          "Failed to generate render function:\n\n" +
            fnGenErrors
              .map(function (_a) {
                var err = _a.err,
                  code = _a.code
                return "".concat(err.toString(), " in\n\n").concat(code, "\n")
              })
              .join("\n"),
          vm
        )
      }
    }
    return (cache[key] = res)
  }
}

function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions)
      var errors = []
      var tips = []
      var warn = function (msg, range, tip) {
        ;(tip ? tips : errors).push(msg)
      }
      if (options) {
        if (options.outputSourceRange) {
          var leadingSpaceLength_1 = template.match(/^\s*/)[0].length
          warn = function (msg, range, tip) {
            var data = typeof msg === "string" ? { msg: msg } : msg
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength_1
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength_1
              }
            }
            ;(tip ? tips : errors).push(data)
          }
        }
        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(
            options.modules
          )
        }
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        for (var key in options) {
          if (key !== "modules" && key !== "directives") {
            finalOptions[key] = options[key]
          }
        }
      }
      finalOptions.warn = warn
      var compiled = baseCompile(template.trim(), finalOptions)
      {
        detectErrors(compiled.ast, warn)
      }
      compiled.errors = errors
      compiled.tips = tips
      return compiled
    }
    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile),
    }
  }
}
```

### 4.3 patch

```js
Vue.prototype.__patch__ = inBrowser ? patch : noop
```

```js
var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules$1 })
```

```js
function createPatchFunction(backend) {
  var i, j
  var cbs = {}
  var modules = backend.modules,
    nodeOps = backend.nodeOps
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = []
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
  }
  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }
  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm)
      }
    }
    remove.listeners = listeners
    return remove
  }
  function removeNode(el) {
    var parent = nodeOps.parentNode(el)
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el)
    }
  }
  function isUnknownElement(vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }
  var creatingElmInVPre = 0
  function createElm(
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index] = cloneVNode(vnode)
    }
    vnode.isRootInsert = !nested
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }
    var data = vnode.data
    var children = vnode.children
    var tag = vnode.tag
    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++
        }
        if (isUnknownElement(vnode, creatingElmInVPre)) {
          warn$2(
            "Unknown custom element: <" +
              tag +
              "> - did you " +
              "register the component correctly? For recursive components, " +
              'make sure to provide the "name" option.',
            vnode.context
          )
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode)
      setScope(vnode)
      createChildren(vnode, children, insertedVnodeQueue)
      if (isDef(data)) {
        invokeCreateHooks(vnode, insertedVnodeQueue)
      }
      insert(parentElm, vnode.elm, refElm)
      if (data && data.pre) {
        creatingElmInVPre--
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text)
      insert(parentElm, vnode.elm, refElm)
    }
  }
  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive
      if (isDef((i = i.hook)) && isDef((i = i.init))) {
        i(vnode, false)
      }
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue)
        insert(parentElm, vnode.elm, refElm)
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
        }
        return true
      }
    }
  }
  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(
        insertedVnodeQueue,
        vnode.data.pendingInsert
      )
      vnode.data.pendingInsert = null
    }
    vnode.elm = vnode.componentInstance.$el
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue)
      setScope(vnode)
    } else {
      registerRef(vnode)
      insertedVnodeQueue.push(vnode)
    }
  }
  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i
    var innerNode = vnode
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode
      if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode)
        }
        insertedVnodeQueue.push(innerNode)
        break
      }
    }
    insert(parentElm, vnode.elm, refElm)
  }
  function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        if (nodeOps.parentNode(ref) === parent) {
          nodeOps.insertBefore(parent, elm, ref)
        }
      } else {
        nodeOps.appendChild(parent, elm)
      }
    }
  }
  function createChildren(vnode, children, insertedVnodeQueue) {
    if (isArray(children)) {
      {
        checkDuplicateKeys(children)
      }
      for (var i_1 = 0; i_1 < children.length; ++i_1) {
        createElm(
          children[i_1],
          insertedVnodeQueue,
          vnode.elm,
          null,
          true,
          children,
          i_1
        )
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))
    }
  }
  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode
    }
    return isDef(vnode.tag)
  }
  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
      cbs.create[i_2](emptyNode, vnode)
    }
    i = vnode.data.hook
    if (isDef(i)) {
      if (isDef(i.create)) i.create(emptyNode, vnode)
      if (isDef(i.insert)) insertedVnodeQueue.push(vnode)
    }
  }
  function setScope(vnode) {
    var i
    if (isDef((i = vnode.fnScopeId))) {
      nodeOps.setStyleScope(vnode.elm, i)
    } else {
      var ancestor = vnode
      while (ancestor) {
        if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
          nodeOps.setStyleScope(vnode.elm, i)
        }
        ancestor = ancestor.parent
      }
    }
    if (
      isDef((i = activeInstance)) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef((i = i.$options._scopeId))
    ) {
      nodeOps.setStyleScope(vnode.elm, i)
    }
  }
  function addVnodes(
    parentElm,
    refElm,
    vnodes,
    startIdx,
    endIdx,
    insertedVnodeQueue
  ) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(
        vnodes[startIdx],
        insertedVnodeQueue,
        parentElm,
        refElm,
        false,
        vnodes,
        startIdx
      )
    }
  }
  function invokeDestroyHook(vnode) {
    var i, j
    var data = vnode.data
    if (isDef(data)) {
      if (isDef((i = data.hook)) && isDef((i = i.destroy))) i(vnode)
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode)
    }
    if (isDef((i = vnode.children))) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j])
      }
    }
  }
  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx]
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch)
          invokeDestroyHook(ch)
        } else {
          removeNode(ch.elm)
        }
      }
    }
  }
  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i_3
      var listeners = cbs.remove.length + 1
      if (isDef(rm)) {
        rm.listeners += listeners
      } else {
        rm = createRmCb(vnode.elm, listeners)
      }
      if (
        isDef((i_3 = vnode.componentInstance)) &&
        isDef((i_3 = i_3._vnode)) &&
        isDef(i_3.data)
      ) {
        removeAndInvokeRemoveHook(i_3, rm)
      }
      for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
        cbs.remove[i_3](vnode, rm)
      }
      if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {
        i_3(vnode, rm)
      } else {
        rm()
      }
    } else {
      removeNode(vnode.elm)
    }
  }
  function updateChildren(
    parentElm,
    oldCh,
    newCh,
    insertedVnodeQueue,
    removeOnly
  ) {
    var oldStartIdx = 0
    var newStartIdx = 0
    var oldEndIdx = oldCh.length - 1
    var oldStartVnode = oldCh[0]
    var oldEndVnode = oldCh[oldEndIdx]
    var newEndIdx = newCh.length - 1
    var newStartVnode = newCh[0]
    var newEndVnode = newCh[newEndIdx]
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm
    var canMove = !removeOnly
    {
      checkDuplicateKeys(newCh)
    }
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx]
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(
          oldStartVnode,
          newStartVnode,
          insertedVnodeQueue,
          newCh,
          newStartIdx
        )
        oldStartVnode = oldCh[++oldStartIdx]
        newStartVnode = newCh[++newStartIdx]
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(
          oldEndVnode,
          newEndVnode,
          insertedVnodeQueue,
          newCh,
          newEndIdx
        )
        oldEndVnode = oldCh[--oldEndIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(
          oldStartVnode,
          newEndVnode,
          insertedVnodeQueue,
          newCh,
          newEndIdx
        )
        canMove &&
          nodeOps.insertBefore(
            parentElm,
            oldStartVnode.elm,
            nodeOps.nextSibling(oldEndVnode.elm)
          )
        oldStartVnode = oldCh[++oldStartIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(
          oldEndVnode,
          newStartVnode,
          insertedVnodeQueue,
          newCh,
          newStartIdx
        )
        canMove &&
          nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode = oldCh[--oldEndIdx]
        newStartVnode = newCh[++newStartIdx]
      } else {
        if (isUndef(oldKeyToIdx))
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
        if (isUndef(idxInOld)) {
          createElm(
            newStartVnode,
            insertedVnodeQueue,
            parentElm,
            oldStartVnode.elm,
            false,
            newCh,
            newStartIdx
          )
        } else {
          vnodeToMove = oldCh[idxInOld]
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(
              vnodeToMove,
              newStartVnode,
              insertedVnodeQueue,
              newCh,
              newStartIdx
            )
            oldCh[idxInOld] = undefined
            canMove &&
              nodeOps.insertBefore(
                parentElm,
                vnodeToMove.elm,
                oldStartVnode.elm
              )
          } else {
            createElm(
              newStartVnode,
              insertedVnodeQueue,
              parentElm,
              oldStartVnode.elm,
              false,
              newCh,
              newStartIdx
            )
          }
        }
        newStartVnode = newCh[++newStartIdx]
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
      addVnodes(
        parentElm,
        refElm,
        newCh,
        newStartIdx,
        newEndIdx,
        insertedVnodeQueue
      )
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx)
    }
  }
  function checkDuplicateKeys(children) {
    var seenKeys = {}
    for (var i_4 = 0; i_4 < children.length; i_4++) {
      var vnode = children[i_4]
      var key = vnode.key
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn$2(
            "Duplicate keys detected: '".concat(
              key,
              "'. This may cause an update error."
            ),
            vnode.context
          )
        } else {
          seenKeys[key] = true
        }
      }
    }
  }
  function findIdxInOld(node, oldCh, start, end) {
    for (var i_5 = start; i_5 < end; i_5++) {
      var c = oldCh[i_5]
      if (isDef(c) && sameVnode(node, c)) return i_5
    }
  }
  function patchVnode(
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index] = cloneVNode(vnode)
    }
    var elm = (vnode.elm = oldVnode.elm)
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
      } else {
        vnode.isAsyncPlaceholder = true
      }
      return
    }
    if (
      isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance
      return
    }
    var i
    var data = vnode.data
    if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
      i(oldVnode, vnode)
    }
    var oldCh = oldVnode.children
    var ch = vnode.children
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
      if (isDef((i = data.hook)) && isDef((i = i.update))) i(oldVnode, vnode)
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch)
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch)
        }
        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, "")
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1)
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, "")
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text)
    }
    if (isDef(data)) {
      if (isDef((i = data.hook)) && isDef((i = i.postpatch))) i(oldVnode, vnode)
    }
  }
  function invokeInsertHook(vnode, queue, initial) {
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue
    } else {
      for (var i_6 = 0; i_6 < queue.length; ++i_6) {
        queue[i_6].data.hook.insert(queue[i_6])
      }
    }
  }
  var hydrationBailed = false
  var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key")
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i
    var tag = vnode.tag,
      data = vnode.data,
      children = vnode.children
    inVPre = inVPre || (data && data.pre)
    vnode.elm = elm
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true
      return true
    }
    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef((i = data.hook)) && isDef((i = i.init))) i(vnode, true)
      if (isDef((i = vnode.componentInstance))) {
        initComponent(vnode, insertedVnodeQueue)
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue)
        } else {
          if (
            isDef((i = data)) &&
            isDef((i = i.domProps)) &&
            isDef((i = i.innerHTML))
          ) {
            if (i !== elm.innerHTML) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true
                console.warn("Parent: ", elm)
                console.warn("server innerHTML: ", i)
                console.warn("client innerHTML: ", elm.innerHTML)
              }
              return false
            }
          } else {
            var childrenMatch = true
            var childNode = elm.firstChild
            for (var i_7 = 0; i_7 < children.length; i_7++) {
              if (
                !childNode ||
                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)
              ) {
                childrenMatch = false
                break
              }
              childNode = childNode.nextSibling
            }
            if (!childrenMatch || childNode) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true
                console.warn("Parent: ", elm)
                console.warn(
                  "Mismatching childNodes vs. VNodes: ",
                  elm.childNodes,
                  children
                )
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true
            invokeCreateHooks(vnode, insertedVnodeQueue)
            break
          }
        }
        if (!fullInvoke && data["class"]) {
          traverse(data["class"])
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text
    }
    return true
  }
  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return (
        vnode.tag.indexOf("vue-component") === 0 ||
        (!isUnknownElement(vnode, inVPre) &&
          vnode.tag.toLowerCase() ===
            (node.tagName && node.tagName.toLowerCase()))
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }
  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }
    var isInitialPatch = false
    var insertedVnodeQueue = []
    if (isUndef(oldVnode)) {
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      var isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else {
              warn$2(
                "The client-side rendered virtual DOM tree is not matching " +
                  "server-rendered content. This is likely caused by incorrect " +
                  "HTML markup, for example nesting block-level elements inside " +
                  "<p>, or missing <tbody>. Bailing hydration and performing " +
                  "full client-side render."
              )
            }
          }
          oldVnode = emptyNodeAt(oldVnode)
        }
        var oldElm = oldVnode.elm
        var parentElm = nodeOps.parentNode(oldElm)
        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent
          var patchable = isPatchable(vnode)
          while (ancestor) {
            for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
              cbs.destroy[i_8](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
                cbs.create[i_9](emptyNode, ancestor)
              }
              var insert_1 = ancestor.data.hook.insert
              if (insert_1.merged) {
                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {
                  insert_1.fns[i_10]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }
        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }
    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
}
```
