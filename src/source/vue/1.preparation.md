---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 一、Vue 内部原理揭秘

## 全局概览

首先我们来看一个内部流程图。

![](https://user-gold-cdn.xitu.io/2017/12/19/1606e7eaa2a664e8?w=1752&h=1216&f=png&s=190985)

## 初始化及挂载

- 用户在 `new Vue(options)`时会将用户的数据传递到 vue 内部做处理。

// 1.需要编译器的版本

```js
new Vue({ template: "<div>{{ hi }}</div>" }).$mount("#app")
```

// 2.这种情况不需要

```js
new Vue({
  render(h) {
    return h("div", this.hi)
  },
}).$mount("#app")
```

Vue 会调用 `_init` 函数进行初始化

```js
function Vue(options) {
  this._init(options)
}
```

这里的 `init` 过程，它会合并配置，初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。

```js
Vue.prototype._init = function(options) {
  const vm = this
  //1.合并配置（如：用户写的生命周期函数）
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
  )
  initLifecycle(vm) //2.初始化生命周期
  initEvents(vm) //3.初始化事件
  initRender(vm) //4.初始化渲染函数
  callHook(vm, "beforeCreate") //5.使用callHook调用生命周期函数
  initInjections(vm) //6.初始化inject
  initState(vm) //7.初始化data、props、methods、computed、watch
  initProvide(vm) //8.初始化provide
  callHook(vm, "created") //9.使用callHook调用生命周期函数
  if (vm.$options.el) {
    vm.$mount(vm.$options.el) //10.挂载到根节点上
  }
}
```

- 7.初始化 data 过程

```js
function initState(vm) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props) //初始化props
  if (opts.methods) initMethods(vm, opts.methods) //methods
  if (opts.data) {
    initData(vm) //初始化data
  } else {
    observe((vm._data = {}), true /* asRootData */) //初始化props
  }
  if (opts.computed) initComputed(vm, opts.computed) //初始化computed
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch) //初始化computed
  }
}
```

其中最重要的是通过 `Object.defineProperty` 设置 `setter` 与 `getter` 函数，用来实现「**响应式**」以及「**依赖收集**」，后面会详细讲到，这里只要有一个印象即可。

- 10.挂载到根节点上

初始化之后调用 `$mount` 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「**编译**」步骤。

## 编译

compile 编译可以分成 `parse`、`optimize` 与 `generate` 三个阶段，最终需要得到 render function。

### parse

`parse` 会用正则等方式解析 template 模板中的指令、class、style 等数据，形成 AST。

### optimize

`optimize` 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 `update` 更新界面时，会有一个 `patch` 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 `patch` 的性能。

### generate

`generate` 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。

在经历过 `parse`、`optimize` 与 `generate` 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。

## 响应式

这里的 `getter` 跟 `setter` 已经在之前介绍过了，在 `init` 的时候通过 `Object.defineProperty` 进行了绑定，它使得当被设置的对象被读取的时候会执行 `getter` 函数，而在当被赋值的时候会执行 `setter` 函数。

当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 `getter` 函数进行「**依赖收集**」，「**依赖收集**」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。

在修改对象的值的时候，会触发对应的 `setter`， `setter` 通知之前「**依赖收集**」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 `update` 来更新视图，当然这中间还有一个 `patch` 的过程以及使用队列来异步更新的策略，这个我们后面再讲。

## Virtual DOM

我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。

## 更新视图

前面我们说到，在修改一个对象值的时候，会通过 `setter -> Watcher -> update` 的流程来修改对应的视图，那么最终是如何更新视图的呢？

当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 `innerHTML` 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「**浪费**」。

那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「**`patch`**」了。我们会将新的 VNode 与旧的 VNode 一起传入 `patch` 进行比较，经过 diff 算法得出它们的「**差异**」。最后我们只需要将这些「**差异**」的对应 DOM 进行修改即可。
