---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: Vue2.x 全家桶相关知识点总结
  - name: keywords
    content: Vue2.x基础知识点技巧介绍
---

# 二.Vue2.x（base）

::: tip 前言
总结一些 vue 中常见的很实用的功能，可以更高效的进行项目开发
:::

## 1.模板打印

```js
Vue.prototype.$log = window.console.log
```

:::demo

```vue
<template>
  <div>
    <el-button @click="msg = Math.random()">修改</el-button>
    <span>{{ msg }}{{ $log(msg) }}</span>
  </div>
</template>
<script>
export default {
  data() {
    return {
      msg: "aaaaa------",
    }
  },
}
</script>
```

:::

## 2.异常捕获

**在 Vue2.x 中用 window.onerror 是捕获不到异常的，异常被框架自身的异常机制捕获了，可以使用`errorHandle`来获取**

```js
Vue.config.errorHandler = function (err, vm, info) {
  let { message, name, stack } = err
  console.error(name, message, stack)
}
```

- 打开控制台，点击内容可以看到捕捉的报错信息

:::demo

```vue
<template>
  <el-button @click="doSomething">点击报错</el-button>
</template>
<script>
export default {
  methods: {
    doSomething() {
      conosle.log(a) // a is not defined
    },
  },
}
</script>
```

:::

::: warning 注意
使用 Vue 中的异常捕获机制，我们可以针对捕获到的数据进行分析和上报，为实现前端异常监控奠定基础
:::

## 3.全局提示

**将 ui 组件（如：elementUI）提示组件挂载到 vue 原型上，在组件中可以通过 this 直接调用提示组件**

```js
Vue.prototype.$message = message
```

:::demo

```vue
<template>
  <el-button @click="handleRequest">请求数据成功</el-button>
</template>
<script>
export default {
  methods: {
    handleRequest() {
      this.$message.success("请求数据成功")
    },
  },
}
</script>
```

:::

## 4.$nextTick

**一般在 vue 项目中异步操作尽量用`nextTick`处理，常见的处理场景：等待 DOM 的更新后操作数据**

```js
this.$nextTick(() => {
  this.$refs.box.getElementsByTagName("li")[0].innerHTML = "覆盖的数据"
})
```

> **nextTick async/await 用法：**

::: demo

```vue {17-18}
<template>
  <ul ref="box">
    <el-button @click="getData">设置数据</el-button>
    <li v-for="(item, index) in arr" :key="index">{{ item }}</li>
  </ul>
</template>
<script>
export default {
  data() {
    return {
      arr: [],
    }
  },
  methods: {
    async getData() {
      this.arr = [1, 2, 3]
      await this.$nextTick()
      this.$refs.box.getElementsByTagName("li")[0].innerHTML = "覆盖的数据"
    },
  },
}
</script>
```

:::

## 5.$watch

- 由于是函数式写法，$watch 相比配置的 watch 可以精确控制初始化时间

::: demo

```vue
<template>
  <el-button @click="data.value = Math.random()">修改</el-button>
</template>
<script>
export default {
  data() {
    return {
      data: { value: 1 },
    }
  },
  // watch: {
  //   data(newVal, oldVal) {
  //       this.$message("修改数据：" + newVal);
  //     },
  // },
  // watch: {
  //   'data.value': {
  //     handler: function (newVal, oldVal) {
  //       this.$message("修改数据：" + newVal);
  //     },
  //     immediatte: true, // 设置为 true 将立即以表达式的当前值触发回调
  //   },
  // },
  // watch: {
  //   data: {
  //     handler: function (newVal, oldVal) {
  //       this.$message("修改数据：" + newVal.value);
  //     },
  //     deep: true, // 设置为 true 用于监听对象内部值得变化
  //     immediatte: true, // 设置为 true 将立即以表达式的当前值触发回调
  //   },
  // },
  mounted() {
    this.$watch("data", {
      handler: function (newVal, oldVal) {
        this.$message("修改数据：" + newVal.value)
      },
      deep: true,
      immediatte: true,
    })
  },
}
</script>
```

:::

**使用场景**

- 1.echarts 图表中需要等数据初始化完成后再监听数据

::: warning 注意

- 1.watch 非常消耗性能，尽量减少 watch 的使用，能用 computed 代替的用其代替

:::

## 6.v-once

Vue 提供了`v-once`指令用于只渲染元素和组件一次，一般可以用于存在大量静态数据组件的更新性能优化，注意是大量静态数据，因为少数情况下我们的页面渲染会因为一些静态数据而变慢。

```vue
<my-component v-once :data="msg"></my-component>
```

这时候因为组件绑定了 v-once，所以无论 msg 的值如何变化，组件内渲染的永远是其第一次获取到的初始值。因此我们在使用 v-once 的时候需要考虑该组件今后的更新情况，避免不必要的问题产生。

## 7.$isServer

判断是否是在服务端渲染(SSR)

- 其他方式判断：

```js
try {
  document.titls = "test"
} catch (e) {}
// process.env.VUE_ENV 需要在 webpack中进行配置
if (process.env.VUE_ENV === "client") {
  document.title = "test"
}
```

- $isServer 判断

```js
if (this.$isServer) {
  document.title = "test"
}
```

## 8.$mount

手动挂载，可以在一些 js 封装的库中受到挂载 vue 组件

```js
let vm = new Vue({
  data: { state: { count: 0 } },
  render(h)=>h(com)
});
vm.$mount("#app");
```

手动插入 dom，可以在一些 js 封装的库中受到挂载 vue 组件

```js
let vm = new Vue({
  data: { state: { count: 0 } },
  render(h)=>h(com)
});
let dom = vm.$mount().innerHTML; // 生成dom元素
```

**使用场景**

- 1.echarts 图表中自定义弹框需要用 vue 来写的部分

## 9.v-model

- `:value` + `@input` 写法实现双向数据绑定
- 组件封装时，可以扩展使用`v-model`

::: demo

```vue
<template>
  <el-input type="text" :value="msg" @input="handleInput" />
  {{ msg }}
</template>

<script>
export default {
  data() {
    return {
      msg: "请输入",
    }
  },
  methods: {
    handleInput(e) {
      this.msg = e.target.value
    },
  },
}
</script>
```

:::

## 10.修饰符

- trim：去掉前后空格（文本粘贴到输入框中很多时候有这种问题）

::: demo

```vue
<template>
  <el-input type="text" v-model.number.trim="msg" />
  {{ msg }}
</template>

<script>
export default {
  data() {
    return {
      msg: "",
    }
  },
}
</script>
```

:::

```vue
<template>
  <!-- 修改符 .number数组 .trim空格 -->
  <input type="text" v-model.number.trim="val" />{{ typeof val }}
  <!-- 修饰符 键盘修饰符 鼠标修饰符 常用的.ctrl .esc .enter-->
  <input type="text" @keyup.esc="fn" />
  <input type="text" @keyup.f1="fn" />
  <!-- 同时 -->
  <input type="text" @keyup.ctrl.enter="fn" />
</template>
```

## 11.样式写法

- 对象写法

::: demo

```vue
<template>
  <div>
    <el-button @click="changeColor">改变颜色</el-button>
    <div :class="{ 'text-green': true, 'text-blue': show }">你好</div>
    <div style="color:red" :style="{ background: 'lightblue' }">xxx</div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      show: false,
    }
  },
  methods: {
    changeColor() {
      this.show = !this.show
    },
  },
}
</script>
<style>
.text-green {
  color: green;
}
.text-blue {
  color: blue;
}
</style>
```

:::

- 数组写法

::: demo

```vue
<template>
  <div class="abc" :class="['a', 'b', 'c']">你好</div>
  <div style="color:red" :style="[{ background: 'lightgray', color: 'blue' }]">
    xxx
  </div>
</template>
```

:::

## 12.slot

- 具名插槽传递参数

## 13.component

- 动态组件切换不同类型的组件

::: demo

```vue
<template>
  <div>
    <el-form>
      <el-form-item>
        <component
          v-if="data.name"
          :is="data.name"
          v-bind="data.props"
        ></component>
      </el-form-item>
    </el-form>
    <el-button @click="handleChange('el-input')">el-input</el-button>
    <el-button @click="handleChange('el-radio')">el-radio</el-button>
    <el-button @click="handleChange('el-select')">el-select</el-button>
  </div>
</template>
<script>
export default {
  data() {
    return {
      data: {
        name: "",
        props: {},
      },
      target: Object.freeze({
        "el-input": {
          name: "el-input",
          props: { value: "10" },
        },
        "el-radio": {
          name: "el-radio",
          props: { value: '1' ,label:"1"},
        },
        "el-select": {
          name: "el-select",
          props: { value: "相机" },
        },
      }),
    }
  },
  methods: {
    handleChange(name) {
      this.data = this.target[name]
    },
  },
}
</script>
```

:::

## 14.functional

- 组件只用于展示数据，所有动态数据都从父组件传递进来（只有 props），内部没有逻辑交互（无 methods 方法、也没有 mounted 等任何生命周期处理函数），没有状态修改(无 data)，推荐使用函数式组件来提升 vue 的性能

```vue
<template functional>
  <ul>
    <li
      v-for="(item, index) in props.items"
      :key="index"
      @click="props.itemClick(item)"
    >
      {{ item }}
    </li>
  </ul>
</template>
```

## 15.$forceUpdate

- 组件强制更新

::: demo

```vue
<template>
  <div>
    <el-form ref="comps">
      <el-form-item>
        <div ref="text">{{ Math.random() }}</div>
      </el-form-item>
    </el-form>
    <el-button type="primary" @click="text">更新</el-button>
    <el-button type="warngin" @click="update">强制更新</el-button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      msg: "11111",
    }
  },

  methods: {
    text() {
      this.$refs.text.innerText = "asdfasdfasd"
    },
    update() {
      this.$refs.comps.$forceUpdate()
    },
  },
}
</script>
```

:::
