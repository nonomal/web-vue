---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 四.vue 中 typescript 基础

## 1.环境配置

## 2.基础类型

### 2.1 boolean、number、string

```ts
let bool: boolean = true
let num: number = 10
let str: string = "hello"
```

### 2.2 元组类型

限制长度个数、类型一一对应

```ts
let tuple: [string, number, boolean] = ["hello", 10, true]
tuple.push("abc") //在元组中增加数据，只能增加元组中存放的类型
```

### 2.3 数组

```ts
let arr1: number[] = [1, 2, 3]
let arr2: string[] = ["1", "2", "3"]
let arr3: (number | string)[] = [1, "2", 3]
let arr4: Array<number | string> = [1, "2", 3] //使用泛型方式来声明
```

### 2.4 枚举类型

```ts
enum USER_ROLE {
  USER, // 默认从0开始
  ADMIN,
  MANAGER,
}
// {0: "USER", 1: "ADMIN", 2: "MANAGER", USER: 0, ADMIN: 1, MANAGER: 2}
```

- 异构枚举

```ts
enum USER_ROLE {
  USER = "user",
  ADMIN = 1,
  MANAGER,
}
```

- 常量枚举

```ts
const enum USER_ROLE {
  USER,
  ADMIN,
  MANAGER,
}
```

### 2.5 any 类型

不进行类型检测

```ts
let arr: any = ["abc", true, { name: "123" }]
```

### 2.6 null 和 undefined

任何类型的子类型，如果`strictNullChecks`的值为 true，则不能把 null 和 undefined 付给其他类型

```ts
let name: number | boolean
name = null
```

### 2.7 void 类型

只能接受 null，undefined。一般用于函数的返回值

```ts
let a: void
a = undefined
```

严格模式下不能将`null`赋予给 void

### 2.8 never 类型

任何类型的子类型，never 代表不会出现的值。不能把其他类型赋值给 never

```ts
function error(message: string): never {
  throw new Error("err")
}
function loop(): never {
  while (true) {}
}
function fn(x: number | string) {
  if (typeof x === "number") {
  } else if (typeof x === "string") {
  } else {
    console.log(x) //never
  }
}
```

### 2.9 Symbol 类型

Symbol 表示独一无二

```ts
const s1 = Symbol("key")
const s2 = Symbol("key")
console.log(s1 === s2)
```

### 2.10 BigInt 类型

```ts
const num1 = Number.MAX_SAFE_INTEGER + 1
const num2 = Number.MAX_SAFE_INTEGER + 2
console.log(num1 === num2) // true
let max: bigint = BigInt(Number.MAX_SAFE_INTEGER)
console.log(max + BigInt(1) === max + BigInt(2))
```

number 类型和 bigInt 类型时不兼容的

### 2.11 object 对象类型

object 表示非原始类型

```ts
let create = (obj:object):void =>{}
create(())
create({})
create([])
create(function(){})
```

## 3.类型推到

### 3.1 类型推导

- 声明变量没有赋予值时默认变量是`any`类型

```ts
let name //类型为any
name = "abc"
name = 10
```

- 声明变量赋值时则以赋值类型为准

```ts
let name = "abc" //name被推导为字符串类型
name = 10
```

### 3.2 包装对象

我们在使用基本数据类型时，调用基本数据类型上的方法，默认会将原始数据类型包装成对象类型

```ts
let bool1: boolean = true
let bool2: boolean = Boolean(1)
let bool3: Booolen = new Boolean(2)
```

boolean 是基本数据类型，Boolean 是他的封装类

### 3.3 联合类型

在使用联合类型时，没有赋值只能访问联合类型中共有的方法和属性

```ts
let name: string | number //联合类型
console.log(name!.toString()) // 公共方法
name = 10
console.log(name!.toFixed(2)) // number方法
name = "aaa"
console.log(name!.toLowerCase()) //字符串方法
```
这里的!表示此值非空
```ts
let ele: HTMLElement | null = document.getElementById('#app');
ele!.style.color = 'red'; // 断定ele元素一定有值
```
## 4.函数类型

## 5.类

## 6.接口

## 7.泛型

## 8.兼容性

## 9.类型保护

## 10.类型推断

## 11.交叉类型

## 12.条件类型

## 13.内置类型

## 14.装包和拆包

## 15.自定义类型

## 16.unknown

## 17.模块和命名空间

## 18.类型声明

## 19.扩展全局变量类型
